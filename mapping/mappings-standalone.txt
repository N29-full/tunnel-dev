baritone.Baritone -> baritone.a:
    java.util.concurrent.ThreadPoolExecutor threadPool -> a
    emh mc -> a
    java.nio.file.Path directory -> a
    baritone.event.GameEventHandler gameEventHandler -> a
    baritone.behavior.PathingBehavior pathingBehavior -> a
    baritone.behavior.LookBehavior lookBehavior -> a
    baritone.behavior.InventoryBehavior inventoryBehavior -> a
    baritone.utils.InputOverrideHandler inputOverrideHandler -> a
    baritone.process.FollowProcess followProcess -> a
    baritone.process.MineProcess mineProcess -> a
    baritone.process.GetToBlockProcess getToBlockProcess -> a
    baritone.process.CustomGoalProcess customGoalProcess -> a
    baritone.process.BuilderProcess builderProcess -> a
    baritone.process.ExploreProcess exploreProcess -> a
    baritone.process.FarmProcess farmProcess -> a
    baritone.process.InventoryPauserProcess inventoryPauserProcess -> a
    baritone.api.process.IElytraProcess elytraProcess -> a
    baritone.utils.PathingControlManager pathingControlManager -> a
    baritone.selection.SelectionManager selectionManager -> a
    baritone.command.manager.CommandManager commandManager -> a
    baritone.api.utils.IPlayerContext playerContext -> a
    baritone.cache.WorldProvider worldProvider -> a
    baritone.utils.BlockStateInterface bsi -> a
    void <init>(emh) -> <init>
    void registerBehavior$cdcab92(baritone.api.event.listener.AbstractGameEventListener) -> a
    baritone.api.event.listener.AbstractGameEventListener registerBehavior$f62ad2c(java.util.function.Function) -> a
    baritone.api.process.IBaritoneProcess registerProcess(java.util.function.Function) -> a
    baritone.api.utils.IPlayerContext getPlayerContext() -> a
    baritone.api.event.listener.IEventBus getGameEventHandler() -> a
    baritone.api.process.IElytraProcess getElytraProcess() -> a
    void openClick() -> a
    baritone.api.Settings settings() -> a
    java.util.concurrent.Executor getExecutor() -> a
    baritone.api.command.manager.ICommandManager getCommandManager() -> a
    baritone.api.selection.ISelectionManager getSelectionManager() -> a
    baritone.api.utils.IInputOverrideHandler getInputOverrideHandler() -> a
    baritone.api.pathing.calc.IPathingControlManager getPathingControlManager() -> a
    baritone.api.cache.IWorldProvider getWorldProvider() -> a
    baritone.api.process.IGetToBlockProcess getGetToBlockProcess() -> a
    baritone.api.process.ICustomGoalProcess getCustomGoalProcess() -> a
    baritone.api.process.IFarmProcess getFarmProcess() -> a
    baritone.api.process.IExploreProcess getExploreProcess() -> a
    baritone.api.process.IBuilderProcess getBuilderProcess() -> a
    baritone.api.process.IMineProcess getMineProcess() -> a
    baritone.api.process.IFollowProcess getFollowProcess() -> a
    baritone.api.behavior.ILookBehavior getLookBehavior() -> a
    baritone.api.behavior.IPathingBehavior getPathingBehavior() -> a
    void lambda$openClick$1() -> b
    void lambda$openClick$0() -> c
    void <clinit>() -> <clinit>
baritone.BaritoneProvider -> baritone.BaritoneProvider:
    java.util.List all -> a
    java.util.List allView -> b
    void <init>() -> <init>
    baritone.api.IBaritone getPrimaryBaritone() -> a
    java.util.List getAllBaritones() -> a
    baritone.api.IBaritone createBaritone(emh) -> b
    baritone.api.cache.IWorldScanner getWorldScanner() -> a
baritone.KeepName -> baritone.b:
baritone.api.BaritoneAPI -> baritone.c:
    baritone.api.IBaritoneProvider provider -> a
    baritone.api.Settings settings -> a
    baritone.api.IBaritoneProvider getProvider() -> a
    baritone.api.Settings getSettings() -> a
    void <clinit>() -> <clinit>
baritone.api.IBaritone -> baritone.d:
    baritone.api.behavior.IPathingBehavior getPathingBehavior() -> a
    baritone.api.behavior.ILookBehavior getLookBehavior() -> a
    baritone.api.process.IFollowProcess getFollowProcess() -> a
    baritone.api.process.IMineProcess getMineProcess() -> a
    baritone.api.process.IBuilderProcess getBuilderProcess() -> a
    baritone.api.process.IExploreProcess getExploreProcess() -> a
    baritone.api.process.IFarmProcess getFarmProcess() -> a
    baritone.api.process.ICustomGoalProcess getCustomGoalProcess() -> a
    baritone.api.process.IGetToBlockProcess getGetToBlockProcess() -> a
    baritone.api.process.IElytraProcess getElytraProcess() -> a
    baritone.api.cache.IWorldProvider getWorldProvider() -> a
    baritone.api.pathing.calc.IPathingControlManager getPathingControlManager() -> a
    baritone.api.utils.IInputOverrideHandler getInputOverrideHandler() -> a
    baritone.api.utils.IPlayerContext getPlayerContext() -> a
    baritone.api.event.listener.IEventBus getGameEventHandler() -> a
    baritone.api.selection.ISelectionManager getSelectionManager() -> a
    baritone.api.command.manager.ICommandManager getCommandManager() -> a
    void openClick() -> a
baritone.api.IBaritoneProvider -> baritone.api.IBaritoneProvider:
    baritone.api.IBaritone getPrimaryBaritone() -> a
    java.util.List getAllBaritones() -> a
    baritone.api.IBaritone getBaritoneForPlayer(fhk) -> a
    baritone.api.IBaritone getBaritoneForMinecraft(emh) -> a
    baritone.api.IBaritone getBaritoneForConnection(fdk) -> a
    baritone.api.cache.IWorldScanner getWorldScanner() -> a
baritone.api.Settings -> baritone.e:
    org.slf4j.Logger LOGGER -> a
    baritone.api.Settings$Setting allowBreak -> allowBreak
    baritone.api.Settings$Setting allowBreakAnyway -> allowBreakAnyway
    baritone.api.Settings$Setting allowSprint -> allowSprint
    baritone.api.Settings$Setting allowPlace -> allowPlace
    baritone.api.Settings$Setting allowPlaceInFluidsSource -> allowPlaceInFluidsSource
    baritone.api.Settings$Setting allowPlaceInFluidsFlow -> allowPlaceInFluidsFlow
    baritone.api.Settings$Setting allowInventory -> allowInventory
    baritone.api.Settings$Setting ticksBetweenInventoryMoves -> ticksBetweenInventoryMoves
    baritone.api.Settings$Setting inventoryMoveOnlyIfStationary -> inventoryMoveOnlyIfStationary
    baritone.api.Settings$Setting assumeExternalAutoTool -> assumeExternalAutoTool
    baritone.api.Settings$Setting autoTool -> autoTool
    baritone.api.Settings$Setting blockPlacementPenalty -> blockPlacementPenalty
    baritone.api.Settings$Setting blockBreakAdditionalPenalty -> blockBreakAdditionalPenalty
    baritone.api.Settings$Setting jumpPenalty -> jumpPenalty
    baritone.api.Settings$Setting walkOnWaterOnePenalty -> walkOnWaterOnePenalty
    baritone.api.Settings$Setting strictLiquidCheck -> strictLiquidCheck
    baritone.api.Settings$Setting allowWaterBucketFall -> allowWaterBucketFall
    baritone.api.Settings$Setting assumeWalkOnWater -> assumeWalkOnWater
    baritone.api.Settings$Setting assumeWalkOnLava -> assumeWalkOnLava
    baritone.api.Settings$Setting assumeStep -> assumeStep
    baritone.api.Settings$Setting assumeSafeWalk -> assumeSafeWalk
    baritone.api.Settings$Setting allowJumpAtBuildLimit -> allowJumpAtBuildLimit
    baritone.api.Settings$Setting allowJumpAt256 -> allowJumpAt256
    baritone.api.Settings$Setting allowParkourAscend -> allowParkourAscend
    baritone.api.Settings$Setting allowDiagonalDescend -> allowDiagonalDescend
    baritone.api.Settings$Setting allowDiagonalAscend -> allowDiagonalAscend
    baritone.api.Settings$Setting allowDownward -> allowDownward
    baritone.api.Settings$Setting acceptableThrowawayItems -> acceptableThrowawayItems
    baritone.api.Settings$Setting blocksToAvoid -> blocksToAvoid
    baritone.api.Settings$Setting blocksToDisallowBreaking -> blocksToDisallowBreaking
    baritone.api.Settings$Setting blocksToAvoidBreaking -> blocksToAvoidBreaking
    baritone.api.Settings$Setting avoidBreakingMultiplier -> avoidBreakingMultiplier
    baritone.api.Settings$Setting buildIgnoreBlocks -> buildIgnoreBlocks
    baritone.api.Settings$Setting buildSkipBlocks -> buildSkipBlocks
    baritone.api.Settings$Setting buildValidSubstitutes -> buildValidSubstitutes
    baritone.api.Settings$Setting buildSubstitutes -> buildSubstitutes
    baritone.api.Settings$Setting okIfAir -> okIfAir
    baritone.api.Settings$Setting buildIgnoreExisting -> buildIgnoreExisting
    baritone.api.Settings$Setting buildIgnoreDirection -> buildIgnoreDirection
    baritone.api.Settings$Setting buildIgnoreProperties -> buildIgnoreProperties
    baritone.api.Settings$Setting avoidUpdatingFallingBlocks -> avoidUpdatingFallingBlocks
    baritone.api.Settings$Setting allowVines -> allowVines
    baritone.api.Settings$Setting allowWalkOnBottomSlab -> allowWalkOnBottomSlab
    baritone.api.Settings$Setting allowParkour -> allowParkour
    baritone.api.Settings$Setting allowParkourPlace -> allowParkourPlace
    baritone.api.Settings$Setting considerPotionEffects -> considerPotionEffects
    baritone.api.Settings$Setting sprintAscends -> sprintAscends
    baritone.api.Settings$Setting overshootTraverse -> overshootTraverse
    baritone.api.Settings$Setting pauseMiningForFallingBlocks -> pauseMiningForFallingBlocks
    baritone.api.Settings$Setting rightClickSpeed -> rightClickSpeed
    baritone.api.Settings$Setting randomLooking113 -> randomLooking113
    baritone.api.Settings$Setting blockReachDistance -> blockReachDistance
    baritone.api.Settings$Setting blockBreakSpeed -> blockBreakSpeed
    baritone.api.Settings$Setting randomLooking -> randomLooking
    baritone.api.Settings$Setting costHeuristic -> costHeuristic
    baritone.api.Settings$Setting pathingMaxChunkBorderFetch -> pathingMaxChunkBorderFetch
    baritone.api.Settings$Setting backtrackCostFavoringCoefficient -> backtrackCostFavoringCoefficient
    baritone.api.Settings$Setting avoidance -> avoidance
    baritone.api.Settings$Setting mobSpawnerAvoidanceCoefficient -> mobSpawnerAvoidanceCoefficient
    baritone.api.Settings$Setting mobSpawnerAvoidanceRadius -> mobSpawnerAvoidanceRadius
    baritone.api.Settings$Setting mobAvoidanceCoefficient -> mobAvoidanceCoefficient
    baritone.api.Settings$Setting mobAvoidanceRadius -> mobAvoidanceRadius
    baritone.api.Settings$Setting rightClickContainerOnArrival -> rightClickContainerOnArrival
    baritone.api.Settings$Setting enterPortal -> enterPortal
    baritone.api.Settings$Setting minimumImprovementRepropagation -> minimumImprovementRepropagation
    baritone.api.Settings$Setting cutoffAtLoadBoundary -> cutoffAtLoadBoundary
    baritone.api.Settings$Setting maxCostIncrease -> maxCostIncrease
    baritone.api.Settings$Setting costVerificationLookahead -> costVerificationLookahead
    baritone.api.Settings$Setting pathCutoffFactor -> pathCutoffFactor
    baritone.api.Settings$Setting pathCutoffMinimumLength -> pathCutoffMinimumLength
    baritone.api.Settings$Setting planningTickLookahead -> planningTickLookahead
    baritone.api.Settings$Setting pathingMapDefaultSize -> pathingMapDefaultSize
    baritone.api.Settings$Setting pathingMapLoadFactor -> pathingMapLoadFactor
    baritone.api.Settings$Setting maxFallHeightNoWater -> maxFallHeightNoWater
    baritone.api.Settings$Setting maxFallHeightBucket -> maxFallHeightBucket
    baritone.api.Settings$Setting allowOvershootDiagonalDescend -> allowOvershootDiagonalDescend
    baritone.api.Settings$Setting simplifyUnloadedYCoord -> simplifyUnloadedYCoord
    baritone.api.Settings$Setting repackOnAnyBlockChange -> repackOnAnyBlockChange
    baritone.api.Settings$Setting movementTimeoutTicks -> movementTimeoutTicks
    baritone.api.Settings$Setting primaryTimeoutMS -> primaryTimeoutMS
    baritone.api.Settings$Setting failureTimeoutMS -> failureTimeoutMS
    baritone.api.Settings$Setting planAheadPrimaryTimeoutMS -> planAheadPrimaryTimeoutMS
    baritone.api.Settings$Setting planAheadFailureTimeoutMS -> planAheadFailureTimeoutMS
    baritone.api.Settings$Setting slowPath -> slowPath
    baritone.api.Settings$Setting slowPathTimeDelayMS -> slowPathTimeDelayMS
    baritone.api.Settings$Setting slowPathTimeoutMS -> slowPathTimeoutMS
    baritone.api.Settings$Setting doBedWaypoints -> doBedWaypoints
    baritone.api.Settings$Setting doDeathWaypoints -> doDeathWaypoints
    baritone.api.Settings$Setting chunkCaching -> chunkCaching
    baritone.api.Settings$Setting pruneRegionsFromRAM -> pruneRegionsFromRAM
    baritone.api.Settings$Setting chunkPackerQueueMaxSize -> chunkPackerQueueMaxSize
    baritone.api.Settings$Setting backfill -> backfill
    baritone.api.Settings$Setting logAsToast -> logAsToast
    baritone.api.Settings$Setting toastTimer -> toastTimer
    baritone.api.Settings$Setting chatDebug -> chatDebug
    baritone.api.Settings$Setting chatControl -> chatControl
    baritone.api.Settings$Setting chatControlAnyway -> chatControlAnyway
    baritone.api.Settings$Setting renderPath -> renderPath
    baritone.api.Settings$Setting renderPathAsLine -> renderPathAsLine
    baritone.api.Settings$Setting renderGoal -> renderGoal
    baritone.api.Settings$Setting renderGoalAnimated -> renderGoalAnimated
    baritone.api.Settings$Setting renderSelectionBoxes -> renderSelectionBoxes
    baritone.api.Settings$Setting renderGoalIgnoreDepth -> renderGoalIgnoreDepth
    baritone.api.Settings$Setting renderGoalXZBeacon -> renderGoalXZBeacon
    baritone.api.Settings$Setting renderSelectionBoxesIgnoreDepth -> renderSelectionBoxesIgnoreDepth
    baritone.api.Settings$Setting renderPathIgnoreDepth -> renderPathIgnoreDepth
    baritone.api.Settings$Setting pathRenderLineWidthPixels -> pathRenderLineWidthPixels
    baritone.api.Settings$Setting goalRenderLineWidthPixels -> goalRenderLineWidthPixels
    baritone.api.Settings$Setting fadePath -> fadePath
    baritone.api.Settings$Setting freeLook -> freeLook
    baritone.api.Settings$Setting blockFreeLook -> blockFreeLook
    baritone.api.Settings$Setting elytraFreeLook -> elytraFreeLook
    baritone.api.Settings$Setting smoothLook -> smoothLook
    baritone.api.Settings$Setting elytraSmoothLook -> elytraSmoothLook
    baritone.api.Settings$Setting smoothLookTicks -> smoothLookTicks
    baritone.api.Settings$Setting remainWithExistingLookDirection -> remainWithExistingLookDirection
    baritone.api.Settings$Setting antiCheatCompatibility -> antiCheatCompatibility
    baritone.api.Settings$Setting pathThroughCachedOnly -> pathThroughCachedOnly
    baritone.api.Settings$Setting sprintInWater -> sprintInWater
    baritone.api.Settings$Setting blacklistClosestOnFailure -> blacklistClosestOnFailure
    baritone.api.Settings$Setting renderCachedChunks -> renderCachedChunks
    baritone.api.Settings$Setting cachedChunksOpacity -> cachedChunksOpacity
    baritone.api.Settings$Setting prefixControl -> prefixControl
    baritone.api.Settings$Setting prefix -> prefix
    baritone.api.Settings$Setting shortBaritonePrefix -> shortBaritonePrefix
    baritone.api.Settings$Setting useMessageTag -> useMessageTag
    baritone.api.Settings$Setting echoCommands -> echoCommands
    baritone.api.Settings$Setting censorCoordinates -> censorCoordinates
    baritone.api.Settings$Setting censorRanCommands -> censorRanCommands
    baritone.api.Settings$Setting itemSaver -> itemSaver
    baritone.api.Settings$Setting itemSaverThreshold -> itemSaverThreshold
    baritone.api.Settings$Setting preferSilkTouch -> preferSilkTouch
    baritone.api.Settings$Setting walkWhileBreaking -> walkWhileBreaking
    baritone.api.Settings$Setting splicePath -> splicePath
    baritone.api.Settings$Setting maxPathHistoryLength -> maxPathHistoryLength
    baritone.api.Settings$Setting pathHistoryCutoffAmount -> pathHistoryCutoffAmount
    baritone.api.Settings$Setting mineGoalUpdateInterval -> mineGoalUpdateInterval
    baritone.api.Settings$Setting maxCachedWorldScanCount -> maxCachedWorldScanCount
    baritone.api.Settings$Setting mineMaxOreLocationsCount -> mineMaxOreLocationsCount
    baritone.api.Settings$Setting minYLevelWhileMining -> minYLevelWhileMining
    baritone.api.Settings$Setting maxYLevelWhileMining -> maxYLevelWhileMining
    baritone.api.Settings$Setting allowOnlyExposedOres -> allowOnlyExposedOres
    baritone.api.Settings$Setting allowOnlyExposedOresDistance -> allowOnlyExposedOresDistance
    baritone.api.Settings$Setting exploreForBlocks -> exploreForBlocks
    baritone.api.Settings$Setting worldExploringChunkOffset -> worldExploringChunkOffset
    baritone.api.Settings$Setting exploreChunkSetMinimumSize -> exploreChunkSetMinimumSize
    baritone.api.Settings$Setting exploreMaintainY -> exploreMaintainY
    baritone.api.Settings$Setting replantCrops -> replantCrops
    baritone.api.Settings$Setting replantNetherWart -> replantNetherWart
    baritone.api.Settings$Setting farmMaxScanSize -> farmMaxScanSize
    baritone.api.Settings$Setting extendCacheOnThreshold -> extendCacheOnThreshold
    baritone.api.Settings$Setting buildInLayers -> buildInLayers
    baritone.api.Settings$Setting layerOrder -> layerOrder
    baritone.api.Settings$Setting layerHeight -> layerHeight
    baritone.api.Settings$Setting startAtLayer -> startAtLayer
    baritone.api.Settings$Setting skipFailedLayers -> skipFailedLayers
    baritone.api.Settings$Setting buildOnlySelection -> buildOnlySelection
    baritone.api.Settings$Setting buildRepeat -> buildRepeat
    baritone.api.Settings$Setting buildRepeatCount -> buildRepeatCount
    baritone.api.Settings$Setting buildRepeatSneaky -> buildRepeatSneaky
    baritone.api.Settings$Setting breakFromAbove -> breakFromAbove
    baritone.api.Settings$Setting goalBreakFromAbove -> goalBreakFromAbove
    baritone.api.Settings$Setting mapArtMode -> mapArtMode
    baritone.api.Settings$Setting okIfWater -> okIfWater
    baritone.api.Settings$Setting incorrectSize -> incorrectSize
    baritone.api.Settings$Setting breakCorrectBlockPenaltyMultiplier -> breakCorrectBlockPenaltyMultiplier
    baritone.api.Settings$Setting placeIncorrectBlockPenaltyMultiplier -> placeIncorrectBlockPenaltyMultiplier
    baritone.api.Settings$Setting schematicOrientationX -> schematicOrientationX
    baritone.api.Settings$Setting schematicOrientationY -> schematicOrientationY
    baritone.api.Settings$Setting schematicOrientationZ -> schematicOrientationZ
    baritone.api.Settings$Setting buildSchematicRotation -> buildSchematicRotation
    baritone.api.Settings$Setting buildSchematicMirror -> buildSchematicMirror
    baritone.api.Settings$Setting schematicFallbackExtension -> schematicFallbackExtension
    baritone.api.Settings$Setting builderTickScanRadius -> builderTickScanRadius
    baritone.api.Settings$Setting mineScanDroppedItems -> mineScanDroppedItems
    baritone.api.Settings$Setting mineDropLoiterDurationMSThanksLouca -> mineDropLoiterDurationMSThanksLouca
    baritone.api.Settings$Setting distanceTrim -> distanceTrim
    baritone.api.Settings$Setting cancelOnGoalInvalidation -> cancelOnGoalInvalidation
    baritone.api.Settings$Setting axisHeight -> axisHeight
    baritone.api.Settings$Setting disconnectOnArrival -> disconnectOnArrival
    baritone.api.Settings$Setting legitMine -> legitMine
    baritone.api.Settings$Setting legitMineYLevel -> legitMineYLevel
    baritone.api.Settings$Setting legitMineIncludeDiagonals -> legitMineIncludeDiagonals
    baritone.api.Settings$Setting forceInternalMining -> forceInternalMining
    baritone.api.Settings$Setting internalMiningAirException -> internalMiningAirException
    baritone.api.Settings$Setting followOffsetDistance -> followOffsetDistance
    baritone.api.Settings$Setting followOffsetDirection -> followOffsetDirection
    baritone.api.Settings$Setting followRadius -> followRadius
    baritone.api.Settings$Setting followTargetMaxDistance -> followTargetMaxDistance
    baritone.api.Settings$Setting disableCompletionCheck -> disableCompletionCheck
    baritone.api.Settings$Setting cachedChunksExpirySeconds -> cachedChunksExpirySeconds
    baritone.api.Settings$Setting logger -> logger
    baritone.api.Settings$Setting notifier -> notifier
    baritone.api.Settings$Setting toaster -> toaster
    baritone.api.Settings$Setting verboseCommandExceptions -> verboseCommandExceptions
    baritone.api.Settings$Setting yLevelBoxSize -> yLevelBoxSize
    baritone.api.Settings$Setting colorCurrentPath -> colorCurrentPath
    baritone.api.Settings$Setting colorNextPath -> colorNextPath
    baritone.api.Settings$Setting colorBlocksToBreak -> colorBlocksToBreak
    baritone.api.Settings$Setting colorBlocksToPlace -> colorBlocksToPlace
    baritone.api.Settings$Setting colorBlocksToWalkInto -> colorBlocksToWalkInto
    baritone.api.Settings$Setting colorBestPathSoFar -> colorBestPathSoFar
    baritone.api.Settings$Setting colorMostRecentConsidered -> colorMostRecentConsidered
    baritone.api.Settings$Setting colorGoalBox -> colorGoalBox
    baritone.api.Settings$Setting colorInvertedGoalBox -> colorInvertedGoalBox
    baritone.api.Settings$Setting colorSelection -> colorSelection
    baritone.api.Settings$Setting colorSelectionPos1 -> colorSelectionPos1
    baritone.api.Settings$Setting colorSelectionPos2 -> colorSelectionPos2
    baritone.api.Settings$Setting selectionOpacity -> selectionOpacity
    baritone.api.Settings$Setting selectionLineWidth -> selectionLineWidth
    baritone.api.Settings$Setting renderSelection -> renderSelection
    baritone.api.Settings$Setting renderSelectionIgnoreDepth -> renderSelectionIgnoreDepth
    baritone.api.Settings$Setting renderSelectionCorners -> renderSelectionCorners
    baritone.api.Settings$Setting useSwordToMine -> useSwordToMine
    baritone.api.Settings$Setting desktopNotifications -> desktopNotifications
    baritone.api.Settings$Setting notificationOnPathComplete -> notificationOnPathComplete
    baritone.api.Settings$Setting notificationOnFarmFail -> notificationOnFarmFail
    baritone.api.Settings$Setting notificationOnBuildFinished -> notificationOnBuildFinished
    baritone.api.Settings$Setting notificationOnExploreFinished -> notificationOnExploreFinished
    baritone.api.Settings$Setting notificationOnMineFail -> notificationOnMineFail
    baritone.api.Settings$Setting elytraSimulationTicks -> elytraSimulationTicks
    baritone.api.Settings$Setting elytraPitchRange -> elytraPitchRange
    baritone.api.Settings$Setting elytraFireworkSpeed -> elytraFireworkSpeed
    baritone.api.Settings$Setting elytraFireworkSetbackUseDelay -> elytraFireworkSetbackUseDelay
    baritone.api.Settings$Setting elytraMinimumAvoidance -> elytraMinimumAvoidance
    baritone.api.Settings$Setting elytraConserveFireworks -> elytraConserveFireworks
    baritone.api.Settings$Setting elytraRenderRaytraces -> elytraRenderRaytraces
    baritone.api.Settings$Setting elytraRenderHitboxRaytraces -> elytraRenderHitboxRaytraces
    baritone.api.Settings$Setting elytraRenderSimulation -> elytraRenderSimulation
    baritone.api.Settings$Setting elytraAutoJump -> elytraAutoJump
    baritone.api.Settings$Setting elytraNetherSeed -> elytraNetherSeed
    baritone.api.Settings$Setting elytraPredictTerrain -> elytraPredictTerrain
    baritone.api.Settings$Setting elytraAutoSwap -> elytraAutoSwap
    baritone.api.Settings$Setting elytraMinimumDurability -> elytraMinimumDurability
    baritone.api.Settings$Setting elytraMinFireworksBeforeLanding -> elytraMinFireworksBeforeLanding
    baritone.api.Settings$Setting elytraAllowEmergencyLand -> elytraAllowEmergencyLand
    baritone.api.Settings$Setting elytraTimeBetweenCacheCullSecs -> elytraTimeBetweenCacheCullSecs
    baritone.api.Settings$Setting elytraCacheCullDistance -> elytraCacheCullDistance
    baritone.api.Settings$Setting elytraAllowLandOnNetherFortress -> elytraAllowLandOnNetherFortress
    baritone.api.Settings$Setting elytraTermsAccepted -> elytraTermsAccepted
    baritone.api.Settings$Setting elytraChatSpam -> elytraChatSpam
    baritone.api.Settings$Setting allowWalkOnMagmaBlocks -> allowWalkOnMagmaBlocks
    java.util.Map byLowerName -> byLowerName
    java.util.List allSettings -> allSettings
    java.util.Map settingTypes -> settingTypes
    void <init>() -> <init>
    void lambda$new$0(tj) -> a
    void <clinit>() -> <clinit>
baritone.api.Settings$JavaOnly -> baritone.e$a:
baritone.api.Settings$Setting -> baritone.e$b:
    java.lang.Object value -> a
    java.lang.Object defaultValue -> b
    java.lang.String name -> a
    boolean javaOnly -> a
    baritone.api.Settings this$0 -> a
    void <init>(baritone.api.Settings,java.lang.Object) -> <init>
    java.lang.String getName() -> a
    java.lang.String toString() -> toString
    void reset() -> a
    java.lang.reflect.Type getType() -> a
baritone.api.behavior.ILookBehavior -> baritone.f:
    void updateTarget(baritone.api.utils.Rotation,boolean) -> a
    baritone.api.behavior.look.IAimProcessor getAimProcessor() -> a
baritone.api.behavior.IPathingBehavior -> baritone.g:
    java.util.Optional ticksRemainingInSegment() -> a
    java.util.Optional ticksRemainingInSegment(boolean) -> a
    java.util.Optional estimatedTicksToGoal() -> b
    boolean isPathing() -> a
    boolean hasPath() -> b
    boolean cancelEverything() -> c
    void forceCancel() -> a
    baritone.api.pathing.path.IPathExecutor getCurrent() -> a
baritone.api.behavior.look.IAimProcessor -> baritone.h:
    baritone.api.utils.Rotation peekRotation(baritone.api.utils.Rotation) -> a
    baritone.api.behavior.look.IAimProcessor fork$7002412() -> a
    void advance$13462e() -> a
    baritone.api.utils.Rotation nextRotation(baritone.api.utils.Rotation) -> b
baritone.api.cache.ICachedWorld -> baritone.i:
    void queueForPacking(ddy) -> a
    boolean isCached(int,int) -> a
    java.util.ArrayList getLocationsOf(java.lang.String,int,int,int,int) -> a
    void reloadAllFromDisk() -> a
    void save() -> b
baritone.api.cache.IWaypoint -> baritone.j:
    java.lang.String getName() -> a
    baritone.api.cache.IWaypoint$Tag getTag() -> a
    long getCreationTimestamp() -> a
    baritone.api.utils.BetterBlockPos getLocation() -> a
baritone.api.cache.IWaypoint$Tag -> baritone.j$a:
    baritone.api.cache.IWaypoint$Tag HOME -> c
    baritone.api.cache.IWaypoint$Tag DEATH -> a
    baritone.api.cache.IWaypoint$Tag BED -> d
    baritone.api.cache.IWaypoint$Tag USER -> b
    java.lang.String[] names -> a
    baritone.api.cache.IWaypoint$Tag[] $VALUES -> a
    baritone.api.cache.IWaypoint$Tag[] values() -> values
    baritone.api.cache.IWaypoint$Tag valueOf(java.lang.String) -> valueOf
    void <init>(java.lang.String,int,java.lang.String[]) -> <init>
    baritone.api.cache.IWaypoint$Tag getByName(java.lang.String) -> a
    java.lang.String[] getAllNames() -> a
    void <clinit>() -> <clinit>
baritone.api.cache.IWaypointCollection -> baritone.k:
    void addWaypoint(baritone.api.cache.IWaypoint) -> a
    void removeWaypoint(baritone.api.cache.IWaypoint) -> b
    java.util.Set getByTag(baritone.api.cache.IWaypoint$Tag) -> a
    java.util.Set getAllWaypoints() -> a
baritone.api.cache.IWorldData -> baritone.l:
    baritone.api.cache.ICachedWorld getCachedWorld() -> a
    baritone.api.cache.IWaypointCollection getWaypoints() -> a
baritone.api.cache.IWorldProvider -> baritone.m:
    baritone.api.cache.IWorldData getCurrentWorld() -> a
    void ifWorldLoaded(java.util.function.Consumer) -> a
baritone.api.cache.IWorldScanner -> baritone.n:
    java.util.List scanChunkRadius$7fc9620e(baritone.api.utils.IPlayerContext,baritone.api.utils.BlockOptionalMetaLookup,int,int) -> a
    java.util.List scanChunkRadius$1b25c07e(baritone.api.utils.IPlayerContext,java.util.List,int) -> a
    int repack(baritone.api.utils.IPlayerContext) -> a
baritone.api.cache.Waypoint -> baritone.o:
    java.lang.String name -> a
    baritone.api.cache.IWaypoint$Tag tag -> a
    long creationTimestamp -> a
    baritone.api.utils.BetterBlockPos location -> a
    void <init>(java.lang.String,baritone.api.cache.IWaypoint$Tag,baritone.api.utils.BetterBlockPos) -> <init>
    void <init>(java.lang.String,baritone.api.cache.IWaypoint$Tag,baritone.api.utils.BetterBlockPos,long) -> <init>
    int hashCode() -> hashCode
    java.lang.String getName() -> a
    baritone.api.cache.IWaypoint$Tag getTag() -> a
    long getCreationTimestamp() -> a
    baritone.api.utils.BetterBlockPos getLocation() -> a
    java.lang.String toString() -> toString
    boolean equals(java.lang.Object) -> equals
baritone.api.command.Command -> baritone.p:
    baritone.api.IBaritone baritone -> a
    baritone.api.utils.IPlayerContext ctx -> a
    java.util.List names -> a
    void <init>(baritone.api.IBaritone,java.lang.String[]) -> <init>
    java.util.List getNames() -> a
    java.lang.String lambda$new$0(java.lang.String) -> a
baritone.api.command.IBaritoneChatControl -> baritone.q:
    java.lang.String FORCE_COMMAND_PREFIX -> a
    void <clinit>() -> <clinit>
baritone.api.command.ICommand -> baritone.r:
    void execute(java.lang.String,baritone.api.command.argument.IArgConsumer) -> a
    java.util.stream.Stream tabComplete$4a48d085(baritone.api.command.argument.IArgConsumer) -> a
    java.lang.String getShortDesc() -> a
    java.util.List getLongDesc() -> b
    java.util.List getNames() -> a
baritone.api.command.argparser.IArgParser -> baritone.s:
    java.lang.Class getTarget() -> a
baritone.api.command.argparser.IArgParser$Stateless -> baritone.s$a:
    java.lang.Object parseArg(baritone.api.command.argument.ICommandArgument) -> a
baritone.api.command.argument.IArgConsumer -> baritone.t:
    java.util.LinkedList getArgs() -> a
    boolean has(int) -> a
    boolean hasAny() -> a
    boolean hasAtMost(int) -> b
    boolean hasExactly(int) -> c
    boolean hasExactlyOne() -> b
    boolean is(java.lang.Class) -> a
    java.lang.String peekString() -> a
    java.lang.Object peekAsOrNull(java.lang.Class) -> a
    java.lang.Object peekDatatypeOrNull(baritone.api.command.datatypes.IDatatypeFor) -> a
    java.lang.Object peekDatatypeOrNull(baritone.api.command.datatypes.IDatatypePost) -> a
    java.lang.Object peekDatatypePostOrNull(baritone.api.command.datatypes.IDatatypePost,java.lang.Object) -> a
    baritone.api.command.argument.ICommandArgument get() -> a
    java.lang.String getString() -> b
    java.lang.Enum getEnum(java.lang.Class) -> a
    java.lang.Object getAs(java.lang.Class) -> b
    java.lang.Object getAsOrDefault(java.lang.Class,java.lang.Object) -> a
    java.lang.Object getDatatypePost(baritone.api.command.datatypes.IDatatypePost,java.lang.Object) -> b
    java.lang.Object getDatatypeFor(baritone.api.command.datatypes.IDatatypeFor) -> b
    java.util.stream.Stream tabCompleteDatatype(baritone.api.command.datatypes.IDatatype) -> a
    java.lang.String rawRest() -> c
    void requireMin(int) -> a
    void requireMax(int) -> b
    void requireExactly(int) -> c
    baritone.api.command.argument.ICommandArgument consumed() -> b
    java.lang.String consumedString() -> d
baritone.api.command.argument.ICommandArgument -> baritone.u:
    int getIndex() -> a
    java.lang.String getValue() -> a
    java.lang.String getRawRest() -> b
    java.lang.Enum getEnum(java.lang.Class) -> a
    java.lang.Object getAs(java.lang.Class) -> a
    boolean is(java.lang.Class) -> a
baritone.api.command.datatypes.BlockById -> baritone.v:
    baritone.api.command.datatypes.BlockById INSTANCE -> a
    baritone.api.command.datatypes.BlockById[] $VALUES -> a
    baritone.api.command.datatypes.BlockById[] values() -> values
    baritone.api.command.datatypes.BlockById valueOf(java.lang.String) -> valueOf
    void <init>(java.lang.String) -> <init>
    java.util.stream.Stream tabComplete(baritone.api.command.datatypes.IDatatypeContext) -> a
    java.lang.Object get(baritone.api.command.datatypes.IDatatypeContext) -> a
    void <clinit>() -> <clinit>
baritone.api.command.datatypes.EntityClassById -> baritone.w:
    baritone.api.command.datatypes.EntityClassById INSTANCE -> a
    baritone.api.command.datatypes.EntityClassById[] $VALUES -> a
    baritone.api.command.datatypes.EntityClassById[] values() -> values
    baritone.api.command.datatypes.EntityClassById valueOf(java.lang.String) -> valueOf
    void <init>(java.lang.String) -> <init>
    java.util.stream.Stream tabComplete(baritone.api.command.datatypes.IDatatypeContext) -> a
    java.lang.Object get(baritone.api.command.datatypes.IDatatypeContext) -> a
    void <clinit>() -> <clinit>
baritone.api.command.datatypes.ForAxis -> baritone.x:
    baritone.api.command.datatypes.ForAxis INSTANCE -> a
    baritone.api.command.datatypes.ForAxis[] $VALUES -> a
    baritone.api.command.datatypes.ForAxis[] values() -> values
    baritone.api.command.datatypes.ForAxis valueOf(java.lang.String) -> valueOf
    void <init>(java.lang.String) -> <init>
    java.util.stream.Stream tabComplete(baritone.api.command.datatypes.IDatatypeContext) -> a
    java.lang.Object get(baritone.api.command.datatypes.IDatatypeContext) -> a
    void <clinit>() -> <clinit>
baritone.api.command.datatypes.ForBlockOptionalMeta -> baritone.y:
    baritone.api.command.datatypes.ForBlockOptionalMeta INSTANCE -> a
    java.util.regex.Pattern PATTERN -> a
    baritone.api.command.datatypes.ForBlockOptionalMeta[] $VALUES -> a
    baritone.api.command.datatypes.ForBlockOptionalMeta[] values() -> values
    baritone.api.command.datatypes.ForBlockOptionalMeta valueOf(java.lang.String) -> valueOf
    void <init>(java.lang.String) -> <init>
    java.util.stream.Stream tabComplete(baritone.api.command.datatypes.IDatatypeContext) -> a
    java.lang.String[] splitLast(java.lang.String,char) -> a
    java.lang.Object get(baritone.api.command.datatypes.IDatatypeContext) -> a
    java.lang.String lambda$tabComplete$3(java.lang.String,java.lang.String) -> a
    java.lang.String lambda$tabComplete$2(java.lang.String,java.lang.String) -> b
    boolean lambda$tabComplete$1(java.util.Set,java.lang.String) -> a
    java.lang.String lambda$tabComplete$0(java.lang.String) -> a
    void <clinit>() -> <clinit>
baritone.api.command.datatypes.ForDirection -> baritone.z:
    baritone.api.command.datatypes.ForDirection INSTANCE -> a
    baritone.api.command.datatypes.ForDirection[] $VALUES -> a
    baritone.api.command.datatypes.ForDirection[] values() -> values
    baritone.api.command.datatypes.ForDirection valueOf(java.lang.String) -> valueOf
    void <init>(java.lang.String) -> <init>
    java.util.stream.Stream tabComplete(baritone.api.command.datatypes.IDatatypeContext) -> a
    java.lang.Object get(baritone.api.command.datatypes.IDatatypeContext) -> a
    void <clinit>() -> <clinit>
baritone.api.command.datatypes.ForWaypoints -> baritone.aa:
    baritone.api.command.datatypes.ForWaypoints INSTANCE -> a
    baritone.api.command.datatypes.ForWaypoints[] $VALUES -> a
    baritone.api.command.datatypes.ForWaypoints[] values() -> values
    baritone.api.command.datatypes.ForWaypoints valueOf(java.lang.String) -> valueOf
    void <init>(java.lang.String) -> <init>
    java.util.stream.Stream tabComplete(baritone.api.command.datatypes.IDatatypeContext) -> a
    baritone.api.cache.IWaypointCollection waypoints(baritone.api.IBaritone) -> a
    baritone.api.cache.IWaypoint[] getWaypoints(baritone.api.IBaritone) -> a
    baritone.api.cache.IWaypoint[] getWaypointsByTag(baritone.api.IBaritone,baritone.api.cache.IWaypoint$Tag) -> a
    java.lang.Object get(baritone.api.command.datatypes.IDatatypeContext) -> a
    baritone.api.cache.IWaypoint[] lambda$getWaypointsByName$5(int) -> a
    boolean lambda$getWaypointsByName$4(java.lang.String,baritone.api.cache.IWaypoint) -> a
    baritone.api.cache.IWaypoint[] lambda$getWaypointsByTag$3(int) -> b
    java.lang.String[] lambda$getWaypointNames$2(int) -> a
    boolean lambda$getWaypointNames$1(java.lang.String) -> a
    baritone.api.cache.IWaypoint[] lambda$getWaypoints$0(int) -> c
    void <clinit>() -> <clinit>
baritone.api.command.datatypes.IDatatype -> baritone.ab:
    java.util.stream.Stream tabComplete(baritone.api.command.datatypes.IDatatypeContext) -> a
baritone.api.command.datatypes.IDatatypeContext -> baritone.ac:
    baritone.api.IBaritone getBaritone() -> a
    baritone.api.command.argument.IArgConsumer getConsumer() -> a
baritone.api.command.datatypes.IDatatypeFor -> baritone.ad:
    java.lang.Object get(baritone.api.command.datatypes.IDatatypeContext) -> a
baritone.api.command.datatypes.IDatatypePost -> baritone.ae:
    java.lang.Object apply(baritone.api.command.datatypes.IDatatypeContext,java.lang.Object) -> a
baritone.api.command.datatypes.ItemById -> baritone.af:
    baritone.api.command.datatypes.ItemById INSTANCE -> a
    baritone.api.command.datatypes.ItemById[] $VALUES -> a
    baritone.api.command.datatypes.ItemById[] values() -> values
    baritone.api.command.datatypes.ItemById valueOf(java.lang.String) -> valueOf
    void <init>(java.lang.String) -> <init>
    java.util.stream.Stream tabComplete(baritone.api.command.datatypes.IDatatypeContext) -> a
    java.lang.Object get(baritone.api.command.datatypes.IDatatypeContext) -> a
    void <clinit>() -> <clinit>
baritone.api.command.datatypes.NearbyPlayer -> baritone.ag:
    baritone.api.command.datatypes.NearbyPlayer INSTANCE -> a
    baritone.api.command.datatypes.NearbyPlayer[] $VALUES -> a
    baritone.api.command.datatypes.NearbyPlayer[] values() -> values
    baritone.api.command.datatypes.NearbyPlayer valueOf(java.lang.String) -> valueOf
    void <init>(java.lang.String) -> <init>
    java.util.stream.Stream tabComplete(baritone.api.command.datatypes.IDatatypeContext) -> a
    java.util.List getPlayers(baritone.api.command.datatypes.IDatatypeContext) -> a
    java.lang.Object get(baritone.api.command.datatypes.IDatatypeContext) -> a
    boolean lambda$get$0(java.lang.String,bym) -> a
    void <clinit>() -> <clinit>
baritone.api.command.datatypes.RelativeBlockPos -> baritone.ah:
    baritone.api.command.datatypes.RelativeBlockPos INSTANCE -> a
    baritone.api.command.datatypes.RelativeBlockPos[] $VALUES -> a
    baritone.api.command.datatypes.RelativeBlockPos[] values() -> values
    baritone.api.command.datatypes.RelativeBlockPos valueOf(java.lang.String) -> valueOf
    void <init>(java.lang.String) -> <init>
    java.util.stream.Stream tabComplete(baritone.api.command.datatypes.IDatatypeContext) -> a
    java.lang.Object apply(baritone.api.command.datatypes.IDatatypeContext,java.lang.Object) -> a
    void <clinit>() -> <clinit>
baritone.api.command.datatypes.RelativeCoordinate -> baritone.ai:
    baritone.api.command.datatypes.RelativeCoordinate INSTANCE -> a
    java.lang.String ScalesAliasRegex -> a
    java.util.regex.Pattern PATTERN -> a
    baritone.api.command.datatypes.RelativeCoordinate[] $VALUES -> a
    baritone.api.command.datatypes.RelativeCoordinate[] values() -> values
    baritone.api.command.datatypes.RelativeCoordinate valueOf(java.lang.String) -> valueOf
    void <init>(java.lang.String) -> <init>
    java.util.stream.Stream tabComplete(baritone.api.command.datatypes.IDatatypeContext) -> a
    java.lang.Object apply(baritone.api.command.datatypes.IDatatypeContext,java.lang.Object) -> a
    void <clinit>() -> <clinit>
baritone.api.command.datatypes.RelativeFile -> baritone.aj:
    baritone.api.command.datatypes.RelativeFile INSTANCE -> a
    baritone.api.command.datatypes.RelativeFile[] $VALUES -> a
    baritone.api.command.datatypes.RelativeFile[] values() -> values
    baritone.api.command.datatypes.RelativeFile valueOf(java.lang.String) -> valueOf
    void <init>(java.lang.String) -> <init>
    java.io.File apply(baritone.api.command.datatypes.IDatatypeContext,java.io.File) -> a
    java.util.stream.Stream tabComplete(baritone.api.command.datatypes.IDatatypeContext) -> a
    java.io.File getCanonicalFileUnchecked(java.io.File) -> a
    java.util.stream.Stream tabComplete(baritone.api.command.argument.IArgConsumer,java.io.File) -> a
    java.io.File gameDir(emh) -> a
    java.lang.Object apply(baritone.api.command.datatypes.IDatatypeContext,java.lang.Object) -> a
    boolean lambda$tabComplete$2(java.lang.String) -> a
    boolean lambda$tabComplete$1(java.lang.String,java.lang.String) -> a
    java.lang.String lambda$tabComplete$0(java.nio.file.Path,java.nio.file.Path,java.io.File) -> a
    void <clinit>() -> <clinit>
baritone.api.command.datatypes.RelativeGoal -> baritone.ak:
    baritone.api.command.datatypes.RelativeGoal INSTANCE -> a
    baritone.api.command.datatypes.RelativeGoal[] $VALUES -> a
    baritone.api.command.datatypes.RelativeGoal[] values() -> values
    baritone.api.command.datatypes.RelativeGoal valueOf(java.lang.String) -> valueOf
    void <init>(java.lang.String) -> <init>
    java.util.stream.Stream tabComplete(baritone.api.command.datatypes.IDatatypeContext) -> a
    java.lang.Object apply(baritone.api.command.datatypes.IDatatypeContext,java.lang.Object) -> a
    void <clinit>() -> <clinit>
baritone.api.command.datatypes.RelativeGoalBlock -> baritone.al:
    baritone.api.command.datatypes.RelativeGoalBlock INSTANCE -> a
    baritone.api.command.datatypes.RelativeGoalBlock[] $VALUES -> a
    baritone.api.command.datatypes.RelativeGoalBlock[] values() -> values
    baritone.api.command.datatypes.RelativeGoalBlock valueOf(java.lang.String) -> valueOf
    void <init>(java.lang.String) -> <init>
    java.util.stream.Stream tabComplete(baritone.api.command.datatypes.IDatatypeContext) -> a
    java.lang.Object apply(baritone.api.command.datatypes.IDatatypeContext,java.lang.Object) -> a
    void <clinit>() -> <clinit>
baritone.api.command.datatypes.RelativeGoalXZ -> baritone.am:
    baritone.api.command.datatypes.RelativeGoalXZ INSTANCE -> a
    baritone.api.command.datatypes.RelativeGoalXZ[] $VALUES -> a
    baritone.api.command.datatypes.RelativeGoalXZ[] values() -> values
    baritone.api.command.datatypes.RelativeGoalXZ valueOf(java.lang.String) -> valueOf
    void <init>(java.lang.String) -> <init>
    java.util.stream.Stream tabComplete(baritone.api.command.datatypes.IDatatypeContext) -> a
    java.lang.Object apply(baritone.api.command.datatypes.IDatatypeContext,java.lang.Object) -> a
    void <clinit>() -> <clinit>
baritone.api.command.datatypes.RelativeGoalYLevel -> baritone.an:
    baritone.api.command.datatypes.RelativeGoalYLevel INSTANCE -> a
    baritone.api.command.datatypes.RelativeGoalYLevel[] $VALUES -> a
    baritone.api.command.datatypes.RelativeGoalYLevel[] values() -> values
    baritone.api.command.datatypes.RelativeGoalYLevel valueOf(java.lang.String) -> valueOf
    void <init>(java.lang.String) -> <init>
    java.util.stream.Stream tabComplete(baritone.api.command.datatypes.IDatatypeContext) -> a
    java.lang.Object apply(baritone.api.command.datatypes.IDatatypeContext,java.lang.Object) -> a
    void <clinit>() -> <clinit>
baritone.api.command.exception.CommandErrorMessageException -> baritone.ao:
    void <init>(java.lang.String) -> <init>
    void <init>(java.lang.String,java.lang.Throwable) -> <init>
    void <init>(baritone.api.command.argument.ICommandArgument,java.lang.String) -> <init>
    void <init>(baritone.api.command.argument.ICommandArgument,java.lang.String,java.lang.Throwable) -> <init>
    java.lang.String formatMessage(baritone.api.command.argument.ICommandArgument,java.lang.String) -> a
baritone.api.command.exception.CommandException -> baritone.ap:
    void <init>(java.lang.String) -> <init>
    void <init>(java.lang.String,java.lang.Throwable) -> <init>
baritone.api.command.exception.CommandInvalidTypeException -> baritone.aq:
    void <init>(baritone.api.command.argument.ICommandArgument,java.lang.String) -> <init>
    void <init>(baritone.api.command.argument.ICommandArgument,java.lang.String,java.lang.Throwable) -> <init>
    void <init>(baritone.api.command.argument.ICommandArgument,java.lang.String,java.lang.String) -> <init>
baritone.api.command.exception.CommandNoParserForTypeException -> baritone.ar:
    void <init>(java.lang.Class) -> <init>
baritone.api.command.exception.CommandNotEnoughArgumentsException -> baritone.as:
    void <init>(int) -> <init>
baritone.api.command.exception.CommandNotFoundException -> baritone.at:
    void <init>(java.lang.String) -> <init>
    void handle$400e7145() -> a
baritone.api.command.exception.CommandUnhandledException -> baritone.au:
    void <init>(java.lang.String) -> <init>
    void <init>(java.lang.Throwable) -> <init>
    void handle$400e7145() -> a
baritone.api.command.exception.ICommandException -> baritone.av:
    java.lang.String getMessage() -> getMessage
    void handle$400e7145() -> a
baritone.api.command.helpers.Paginator -> baritone.aw:
    java.util.List entries -> a
    int pageSize -> a
    int page -> b
    void <init>(java.util.List) -> <init>
    int getMaxPage() -> a
    boolean validPage(int) -> a
    void paginate(baritone.api.command.argument.IArgConsumer,baritone.api.command.helpers.Paginator,java.lang.Runnable,java.util.function.Function,java.lang.String) -> a
    void paginate(baritone.api.command.argument.IArgConsumer,java.lang.Object[],java.lang.Runnable,java.util.function.Function,java.lang.String) -> a
baritone.api.command.helpers.TabCompleteHelper -> baritone.ax:
    java.util.stream.Stream stream -> a
    void <init>() -> <init>
    baritone.api.command.helpers.TabCompleteHelper append(java.util.stream.Stream) -> a
    baritone.api.command.helpers.TabCompleteHelper append(java.lang.String[]) -> a
    baritone.api.command.helpers.TabCompleteHelper append(java.lang.Class) -> a
    baritone.api.command.helpers.TabCompleteHelper prepend(java.util.stream.Stream) -> b
    baritone.api.command.helpers.TabCompleteHelper prepend(java.lang.String[]) -> b
    baritone.api.command.helpers.TabCompleteHelper map(java.util.function.Function) -> a
    baritone.api.command.helpers.TabCompleteHelper filter(java.util.function.Predicate) -> a
    baritone.api.command.helpers.TabCompleteHelper sort(java.util.Comparator) -> a
    baritone.api.command.helpers.TabCompleteHelper filterPrefix(java.lang.String) -> a
    baritone.api.command.helpers.TabCompleteHelper filterPrefixNamespaced(java.lang.String) -> b
    baritone.api.command.helpers.TabCompleteHelper addCommands(baritone.api.command.manager.ICommandManager) -> a
    baritone.api.command.helpers.TabCompleteHelper addSettings() -> a
    baritone.api.command.helpers.TabCompleteHelper addModifiedSettings() -> b
    baritone.api.command.helpers.TabCompleteHelper addToggleableSettings() -> c
    boolean lambda$addSettings$3(baritone.api.Settings$Setting) -> a
    java.util.stream.Stream lambda$addCommands$2(baritone.api.command.ICommand) -> a
    boolean lambda$filterPrefix$0(java.lang.String,java.lang.String) -> a
baritone.api.command.manager.ICommandManager -> baritone.ay:
    baritone.api.IBaritone getBaritone() -> a
    baritone.api.command.registry.Registry getRegistry() -> a
    baritone.api.command.ICommand getCommand(java.lang.String) -> a
    boolean execute(java.lang.String) -> a
    boolean execute(aqh) -> a
    java.util.stream.Stream tabComplete(java.lang.String) -> a
baritone.api.command.registry.Registry -> baritone.az:
    java.util.Deque _entries -> a
    java.util.Set registered -> a
    java.util.Collection entries -> a
    void <init>() -> <init>
    boolean register(java.lang.Object) -> a
    java.util.Iterator descendingIterator() -> a
    java.util.stream.Stream stream() -> a
    java.util.stream.Stream descendingStream() -> b
baritone.api.event.events.ChatEvent -> baritone.ba:
    java.lang.String message -> a
    void <init>(java.lang.String) -> <init>
baritone.api.event.events.ChunkEvent -> baritone.bb:
    baritone.api.event.events.type.EventState state -> a
    baritone.api.event.events.ChunkEvent$Type type -> a
    int x -> a
    int z -> b
    void <init>(baritone.api.event.events.type.EventState,baritone.api.event.events.ChunkEvent$Type,int,int) -> <init>
    boolean isPostPopulate() -> a
baritone.api.event.events.ChunkEvent$Type -> baritone.bb$a:
    baritone.api.event.events.ChunkEvent$Type LOAD -> d
    baritone.api.event.events.ChunkEvent$Type UNLOAD -> a
    baritone.api.event.events.ChunkEvent$Type POPULATE_FULL -> b
    baritone.api.event.events.ChunkEvent$Type POPULATE_PARTIAL -> c
    baritone.api.event.events.ChunkEvent$Type[] $VALUES -> a
    baritone.api.event.events.ChunkEvent$Type[] values() -> values
    baritone.api.event.events.ChunkEvent$Type valueOf(java.lang.String) -> valueOf
    void <init>(java.lang.String,int) -> <init>
    void <clinit>() -> <clinit>
baritone.api.event.events.PathEvent -> baritone.bc:
    baritone.api.event.events.PathEvent CALC_STARTED -> a
    baritone.api.event.events.PathEvent CALC_FINISHED_NOW_EXECUTING -> b
    baritone.api.event.events.PathEvent CALC_FAILED -> c
    baritone.api.event.events.PathEvent NEXT_SEGMENT_CALC_STARTED -> d
    baritone.api.event.events.PathEvent NEXT_SEGMENT_CALC_FINISHED -> e
    baritone.api.event.events.PathEvent CONTINUING_ONTO_PLANNED_NEXT -> f
    baritone.api.event.events.PathEvent SPLICING_ONTO_NEXT_EARLY -> g
    baritone.api.event.events.PathEvent AT_GOAL -> h
    baritone.api.event.events.PathEvent PATH_FINISHED_NEXT_STILL_CALCULATING -> i
    baritone.api.event.events.PathEvent NEXT_CALC_FAILED -> j
    baritone.api.event.events.PathEvent DISCARD_NEXT -> k
    baritone.api.event.events.PathEvent CANCELED -> l
    baritone.api.event.events.PathEvent[] $VALUES -> a
    baritone.api.event.events.PathEvent[] values() -> values
    baritone.api.event.events.PathEvent valueOf(java.lang.String) -> valueOf
    void <init>(java.lang.String,int) -> <init>
    void <clinit>() -> <clinit>
baritone.api.event.events.RotationMoveEvent -> baritone.bd:
    baritone.api.utils.Rotation original -> a
    float yaw -> a
    float pitch -> b
    void <init>(float,float) -> <init>
baritone.api.event.events.RotationMoveEvent$Type -> baritone.bd$a:
    baritone.api.event.events.RotationMoveEvent$Type MOTION_UPDATE -> a
    baritone.api.event.events.RotationMoveEvent$Type JUMP -> b
    baritone.api.event.events.RotationMoveEvent$Type[] $VALUES -> a
    baritone.api.event.events.RotationMoveEvent$Type[] values() -> values
    baritone.api.event.events.RotationMoveEvent$Type valueOf(java.lang.String) -> valueOf
    void <init>(java.lang.String,int) -> <init>
    void <clinit>() -> <clinit>
baritone.api.event.events.SprintStateEvent -> baritone.be:
    java.lang.Boolean state -> a
    void <init>() -> <init>
baritone.api.event.events.TabCompleteEvent -> baritone.bf:
    java.lang.String prefix -> a
    java.lang.String[] completions -> a
    void <init>(java.lang.String) -> <init>
baritone.api.event.events.TickEvent -> baritone.bg:
    int overallTickCount -> a
    baritone.api.event.events.TickEvent$Type type -> a
    void <init>(baritone.api.event.events.TickEvent$Type) -> <init>
    java.util.function.BiFunction createNextProvider() -> a
    baritone.api.event.events.TickEvent lambda$createNextProvider$0(int,baritone.api.event.events.type.EventState,baritone.api.event.events.TickEvent$Type) -> a
baritone.api.event.events.TickEvent$Type -> baritone.bg$a:
    baritone.api.event.events.TickEvent$Type IN -> a
    baritone.api.event.events.TickEvent$Type OUT -> b
    baritone.api.event.events.TickEvent$Type[] $VALUES -> a
    baritone.api.event.events.TickEvent$Type[] values() -> values
    baritone.api.event.events.TickEvent$Type valueOf(java.lang.String) -> valueOf
    void <init>(java.lang.String,int) -> <init>
    void <clinit>() -> <clinit>
baritone.api.event.events.WorldEvent -> baritone.bh:
    fdj world -> a
    baritone.api.event.events.type.EventState state -> a
    void <init>(fdj,baritone.api.event.events.type.EventState) -> <init>
baritone.api.event.events.type.Cancellable -> baritone.bi:
    boolean cancelled -> a
    void <init>() -> <init>
baritone.api.event.events.type.EventState -> baritone.bj:
    baritone.api.event.events.type.EventState PRE -> a
    baritone.api.event.events.type.EventState POST -> b
    baritone.api.event.events.type.EventState[] $VALUES -> a
    baritone.api.event.events.type.EventState[] values() -> values
    baritone.api.event.events.type.EventState valueOf(java.lang.String) -> valueOf
    void <init>(java.lang.String,int) -> <init>
    void <clinit>() -> <clinit>
baritone.api.event.listener.AbstractGameEventListener -> baritone.bk:
    void onTick(baritone.api.event.events.TickEvent) -> a
    void onPostTick(baritone.api.event.events.TickEvent) -> b
    void onPlayerUpdate$131b5bbf(baritone.api.utils.VecUtils) -> a
    void onSendChatMessage(baritone.api.event.events.ChatEvent) -> a
    void onPreTabComplete(baritone.api.event.events.TabCompleteEvent) -> a
    void onChunkEvent(baritone.api.event.events.ChunkEvent) -> a
    void onBlockChange$4a8de162(baritone.api.utils.NotificationHelper) -> a
    void onRenderPass$493a6673(baritone.cache.ChunkPacker) -> a
    void onWorldEvent(baritone.api.event.events.WorldEvent) -> a
    void onSendPacket$1f25927f(baritone.api.utils.RayTraceUtils) -> a
    void onReceivePacket$1f25927f(baritone.api.utils.RayTraceUtils) -> b
    void onPlayerRotationMove(baritone.api.event.events.RotationMoveEvent) -> a
    void onPlayerSprintState(baritone.api.event.events.SprintStateEvent) -> a
    void onPlayerDeath() -> d_
    void onPathEvent(baritone.api.event.events.PathEvent) -> a
baritone.api.event.listener.IEventBus -> baritone.bl:
    void registerEventListener(baritone.api.event.listener.IGameEventListener) -> a
baritone.api.event.listener.IGameEventListener -> baritone.bm:
    void onTick(baritone.api.event.events.TickEvent) -> a
    void onPostTick(baritone.api.event.events.TickEvent) -> b
    void onPlayerUpdate$131b5bbf(baritone.api.utils.VecUtils) -> a
    void onSendChatMessage(baritone.api.event.events.ChatEvent) -> a
    void onPreTabComplete(baritone.api.event.events.TabCompleteEvent) -> a
    void onChunkEvent(baritone.api.event.events.ChunkEvent) -> a
    void onBlockChange$4a8de162(baritone.api.utils.NotificationHelper) -> a
    void onRenderPass$493a6673(baritone.cache.ChunkPacker) -> a
    void onWorldEvent(baritone.api.event.events.WorldEvent) -> a
    void onSendPacket$1f25927f(baritone.api.utils.RayTraceUtils) -> a
    void onReceivePacket$1f25927f(baritone.api.utils.RayTraceUtils) -> b
    void onPlayerRotationMove(baritone.api.event.events.RotationMoveEvent) -> a
    void onPlayerSprintState(baritone.api.event.events.SprintStateEvent) -> a
    void onPlayerDeath() -> d_
    void onPathEvent(baritone.api.event.events.PathEvent) -> a
baritone.api.pathing.calc.IPath -> baritone.bn:
    java.util.List movements() -> a
    java.util.List positions() -> b
    baritone.api.pathing.calc.IPath postProcess() -> a
    int length() -> a
    baritone.api.pathing.goals.Goal getGoal() -> a
    int getNumNodesConsidered() -> b
    baritone.api.utils.BetterBlockPos getSrc() -> a
    baritone.api.utils.BetterBlockPos getDest() -> b
    double ticksRemainingFrom(int) -> a
    baritone.api.pathing.calc.IPath cutoffAtLoadedChunks(java.lang.Object) -> a
    baritone.api.pathing.calc.IPath staticCutoff(baritone.api.pathing.goals.Goal) -> a
    void sanityCheck() -> a
baritone.api.pathing.calc.IPathingControlManager -> baritone.bo:
    void registerProcess(baritone.api.process.IBaritoneProcess) -> a
    java.util.Optional mostRecentInControl() -> a
    java.util.Optional mostRecentCommand() -> b
baritone.api.pathing.goals.Goal -> baritone.bp:
    boolean isInGoal(int,int,int) -> a
    double heuristic(int,int,int) -> a
    boolean isInGoal(gt) -> a
    double heuristic() -> a
baritone.api.pathing.goals.GoalAxis -> baritone.bq:
    double SQRT_2_OVER_2 -> a
    void <init>() -> <init>
    boolean isInGoal(int,int,int) -> a
    double heuristic(int,int,int) -> a
    boolean equals(java.lang.Object) -> equals
    int hashCode() -> hashCode
    java.lang.String toString() -> toString
    void <clinit>() -> <clinit>
baritone.api.pathing.goals.GoalBlock -> baritone.br:
    int x -> a
    int y -> b
    int z -> c
    void <init>(gt) -> <init>
    void <init>(int,int,int) -> <init>
    boolean isInGoal(int,int,int) -> a
    double heuristic(int,int,int) -> a
    boolean equals(java.lang.Object) -> equals
    int hashCode() -> hashCode
    java.lang.String toString() -> toString
    gt getGoalPos() -> a
    double calculate(double,int,double) -> a
baritone.api.pathing.goals.GoalComposite -> baritone.bs:
    baritone.api.pathing.goals.Goal[] goals -> a
    void <init>(baritone.api.pathing.goals.Goal[]) -> <init>
    boolean isInGoal(int,int,int) -> a
    double heuristic(int,int,int) -> a
    double heuristic() -> a
    boolean equals(java.lang.Object) -> equals
    int hashCode() -> hashCode
    java.lang.String toString() -> toString
baritone.api.pathing.goals.GoalGetToBlock -> baritone.bt:
    int x -> a
    int y -> b
    int z -> c
    void <init>(gt) -> <init>
    gt getGoalPos() -> a
    boolean isInGoal(int,int,int) -> a
    double heuristic(int,int,int) -> a
    boolean equals(java.lang.Object) -> equals
    int hashCode() -> hashCode
    java.lang.String toString() -> toString
baritone.api.pathing.goals.GoalInverted -> baritone.bu:
    baritone.api.pathing.goals.Goal origin -> a
    void <init>(baritone.api.pathing.goals.Goal) -> <init>
    boolean isInGoal(int,int,int) -> a
    double heuristic(int,int,int) -> a
    double heuristic() -> a
    boolean equals(java.lang.Object) -> equals
    int hashCode() -> hashCode
    java.lang.String toString() -> toString
baritone.api.pathing.goals.GoalNear -> baritone.bv:
    int x -> a
    int y -> b
    int z -> c
    int rangeSq -> d
    void <init>(gt,int) -> <init>
    boolean isInGoal(int,int,int) -> a
    double heuristic(int,int,int) -> a
    double heuristic() -> a
    gt getGoalPos() -> a
    boolean equals(java.lang.Object) -> equals
    int hashCode() -> hashCode
    java.lang.String toString() -> toString
baritone.api.pathing.goals.GoalRunAway -> baritone.bw:
    gt[] from -> a
    java.lang.Integer maintainY -> a
    void <init>(gt[]) -> <init>
    void <init>(java.lang.Integer,gt[]) -> <init>
    boolean isInGoal(int,int,int) -> a
    double heuristic(int,int,int) -> a
    double heuristic() -> a
    boolean equals(java.lang.Object) -> equals
    int hashCode() -> hashCode
    java.lang.String toString() -> toString
baritone.api.pathing.goals.GoalStrictDirection -> baritone.bx:
    int x -> a
    int y -> b
    int z -> c
    int dx -> d
    int dz -> e
    void <init>(gt,gz) -> <init>
    boolean isInGoal(int,int,int) -> a
    double heuristic(int,int,int) -> a
    double heuristic() -> a
    boolean equals(java.lang.Object) -> equals
    int hashCode() -> hashCode
    java.lang.String toString() -> toString
baritone.api.pathing.goals.GoalTwoBlocks -> baritone.by:
    int x -> a
    int y -> b
    int z -> c
    void <init>(gt) -> <init>
    void <init>(int,int,int) -> <init>
    boolean isInGoal(int,int,int) -> a
    double heuristic(int,int,int) -> a
    gt getGoalPos() -> a
    boolean equals(java.lang.Object) -> equals
    int hashCode() -> hashCode
    java.lang.String toString() -> toString
baritone.api.pathing.goals.GoalXZ -> baritone.bz:
    double SQRT_2 -> a
    int x -> a
    int z -> b
    void <init>(int,int) -> <init>
    void <init>(baritone.api.utils.BetterBlockPos) -> <init>
    boolean isInGoal(int,int,int) -> a
    double heuristic(int,int,int) -> a
    boolean equals(java.lang.Object) -> equals
    int hashCode() -> hashCode
    java.lang.String toString() -> toString
    double calculate(double,double) -> a
    baritone.api.pathing.goals.GoalXZ fromDirection(ede,float,double) -> a
    void <clinit>() -> <clinit>
baritone.api.pathing.goals.GoalYLevel -> baritone.ca:
    int level -> a
    void <init>(int) -> <init>
    boolean isInGoal(int,int,int) -> a
    double heuristic(int,int,int) -> a
    double calculate(int,int) -> a
    boolean equals(java.lang.Object) -> equals
    int hashCode() -> hashCode
    java.lang.String toString() -> toString
baritone.api.pathing.movement.ActionCosts -> baritone.cb:
    double[] FALL_N_BLOCKS_COST -> a
    double FALL_1_25_BLOCKS_COST -> a
    double FALL_0_25_BLOCKS_COST -> b
    double JUMP_ONE_BLOCK_COST -> c
    double distanceToTicks(double) -> a
    void <clinit>() -> <clinit>
baritone.api.pathing.movement.IMovement -> baritone.cc:
    double getCost() -> a
    void reset() -> a
    boolean safeToCancel() -> a
    baritone.api.utils.BetterBlockPos getSrc() -> a
    baritone.api.utils.BetterBlockPos getDest() -> b
    gt getDirection() -> a
baritone.api.pathing.movement.MovementStatus -> baritone.cd:
    baritone.api.pathing.movement.MovementStatus PREPPING -> a
    baritone.api.pathing.movement.MovementStatus WAITING -> b
    baritone.api.pathing.movement.MovementStatus RUNNING -> c
    baritone.api.pathing.movement.MovementStatus SUCCESS -> d
    baritone.api.pathing.movement.MovementStatus UNREACHABLE -> e
    baritone.api.pathing.movement.MovementStatus FAILED -> f
    baritone.api.pathing.movement.MovementStatus CANCELED -> g
    boolean complete -> a
    baritone.api.pathing.movement.MovementStatus[] $VALUES -> a
    baritone.api.pathing.movement.MovementStatus[] values() -> values
    baritone.api.pathing.movement.MovementStatus valueOf(java.lang.String) -> valueOf
    void <init>(java.lang.String,int,boolean) -> <init>
    void <clinit>() -> <clinit>
baritone.api.pathing.path.IPathExecutor -> baritone.ce:
    baritone.api.pathing.calc.IPath getPath() -> a
    int getPosition() -> a
baritone.api.process.IBaritoneProcess -> baritone.cf:
    boolean isActive() -> a
    baritone.api.process.PathingCommand onTick(boolean,boolean) -> a
    boolean isTemporary() -> b
    void onLostControl() -> a
    double priority() -> a
    java.lang.String displayName() -> a
    java.lang.String displayName0() -> b
baritone.api.process.IBuilderProcess -> baritone.cg:
    void build(java.lang.String,baritone.api.schematic.ISchematic,hy) -> a
    boolean build(java.lang.String,java.io.File,hy) -> a
    void buildOpenLitematic(int) -> a
    void resume() -> b
    void clearArea(gt,gt) -> a
baritone.api.process.ICustomGoalProcess -> baritone.ch:
    void setGoal(baritone.api.pathing.goals.Goal) -> a
    void path() -> b
    baritone.api.pathing.goals.Goal getGoal() -> a
    baritone.api.pathing.goals.Goal mostRecentGoal() -> b
    void setGoalAndPath(baritone.api.pathing.goals.Goal) -> b
baritone.api.process.IElytraProcess -> baritone.ci:
    void repackChunks() -> b
    void pathTo(baritone.api.pathing.goals.Goal) -> a
    void resetState() -> c
    boolean isLoaded() -> c
    boolean isSafeToCancel() -> d
baritone.api.process.IExploreProcess -> baritone.cj:
    void explore(int,int) -> a
    void applyJsonFilter(java.nio.file.Path,boolean) -> a
baritone.api.process.IFarmProcess -> baritone.ck:
    void farm(int,gt) -> a
baritone.api.process.IFollowProcess -> baritone.cl:
    void follow(java.util.function.Predicate) -> a
    void pickup(java.util.function.Predicate) -> b
baritone.api.process.IGetToBlockProcess -> baritone.cm:
    void getToBlock(baritone.api.utils.BlockOptionalMeta) -> a
    boolean blacklistClosest() -> c
baritone.api.process.IMineProcess -> baritone.cn:
    void mine(int,baritone.api.utils.BlockOptionalMetaLookup) -> a
    void mine(int,baritone.api.utils.BlockOptionalMeta[]) -> a
    void cancel() -> b
baritone.api.process.PathingCommand -> baritone.co:
    baritone.api.pathing.goals.Goal goal -> a
    baritone.api.process.PathingCommandType commandType -> a
    void <init>(baritone.api.pathing.goals.Goal,baritone.api.process.PathingCommandType) -> <init>
    java.lang.String toString() -> toString
baritone.api.process.PathingCommandType -> baritone.cp:
    baritone.api.process.PathingCommandType SET_GOAL_AND_PATH -> a
    baritone.api.process.PathingCommandType REQUEST_PAUSE -> b
    baritone.api.process.PathingCommandType CANCEL_AND_SET_GOAL -> c
    baritone.api.process.PathingCommandType REVALIDATE_GOAL_AND_PATH -> d
    baritone.api.process.PathingCommandType FORCE_REVALIDATE_GOAL_AND_PATH -> e
    baritone.api.process.PathingCommandType DEFER -> f
    baritone.api.process.PathingCommandType SET_GOAL_AND_PAUSE -> g
    baritone.api.process.PathingCommandType[] $VALUES -> a
    baritone.api.process.PathingCommandType[] values() -> values
    baritone.api.process.PathingCommandType valueOf(java.lang.String) -> valueOf
    void <init>(java.lang.String,int) -> <init>
    void <clinit>() -> <clinit>
baritone.api.schematic.AbstractSchematic -> baritone.cq:
    int x -> a
    int y -> b
    int z -> c
    void <init>() -> <init>
    void <init>(int,int,int) -> <init>
    int widthX() -> a
    int heightY() -> b
    int lengthZ() -> c
baritone.api.schematic.CompositeSchematic -> baritone.cr:
    java.util.List schematics -> a
    baritone.api.schematic.CompositeSchematicEntry[] schematicArr -> a
    void recalcArr() -> b
    void <init>() -> <init>
    void put(baritone.api.schematic.ISchematic,int,int,int) -> a
    baritone.api.schematic.CompositeSchematicEntry getSchematic(int,int,int,dbq) -> a
    boolean inSchematic(int,int,int,dbq) -> a
    dbq desiredState(int,int,int,dbq,java.util.List) -> a
    void reset() -> a
baritone.api.schematic.CompositeSchematicEntry -> baritone.cs:
    baritone.api.schematic.ISchematic schematic -> a
    int x -> a
    int y -> b
    int z -> c
    void <init>(baritone.api.schematic.ISchematic,int,int,int) -> <init>
baritone.api.schematic.FillSchematic -> baritone.ct:
    baritone.api.utils.BlockOptionalMeta bom -> a
    void <init>(int,int,int,baritone.api.utils.BlockOptionalMeta) -> <init>
    void <init>(int,int,int,dbq) -> <init>
    dbq desiredState(int,int,int,dbq,java.util.List) -> a
baritone.api.schematic.ISchematic -> baritone.cu:
    boolean inSchematic(int,int,int,dbq) -> a
    dbq desiredState(int,int,int,dbq,java.util.List) -> a
    void reset() -> a
    int widthX() -> a
    int heightY() -> b
    int lengthZ() -> c
baritone.api.schematic.IStaticSchematic -> baritone.cv:
    dbq getDirect(int,int,int) -> a
    dbq[] getColumn(int,int) -> a
baritone.api.schematic.MaskSchematic -> baritone.cw:
    baritone.api.schematic.ISchematic schematic -> a
    void <init>(baritone.api.schematic.ISchematic) -> <init>
    boolean partOfMask(int,int,int,dbq) -> b
    boolean inSchematic(int,int,int,dbq) -> a
    dbq desiredState(int,int,int,dbq,java.util.List) -> a
    baritone.api.schematic.MaskSchematic create(baritone.api.schematic.ISchematic,baritone.api.schematic.mask.Mask) -> a
baritone.api.schematic.MaskSchematic$1 -> baritone.cx:
    baritone.api.schematic.mask.Mask val$function -> a
    void <init>(baritone.api.schematic.ISchematic,baritone.api.schematic.mask.Mask) -> <init>
    boolean partOfMask(int,int,int,dbq) -> b
baritone.api.schematic.MirroredSchematic -> baritone.cy:
    baritone.api.schematic.ISchematic schematic -> a
    cua mirror -> a
    void <init>(baritone.api.schematic.ISchematic,cua) -> <init>
    boolean inSchematic(int,int,int,dbq) -> a
    dbq desiredState(int,int,int,dbq,java.util.List) -> a
    void reset() -> a
    int widthX() -> a
    int heightY() -> b
    int lengthZ() -> c
    int mirrorX(int,int,cua) -> a
    int mirrorZ(int,int,cua) -> b
    dbq mirror(dbq,cua) -> a
    dbq lambda$mirror$0(cua,dbq) -> a
baritone.api.schematic.MirroredSchematic$1 -> baritone.cz:
    int[] $SwitchMap$net$minecraft$world$level$block$Mirror -> a
    void <clinit>() -> <clinit>
baritone.api.schematic.ReplaceSchematic -> baritone.da:
    baritone.api.utils.BlockOptionalMetaLookup filter -> a
    java.lang.Boolean[][][] cache -> a
    void <init>(baritone.api.schematic.ISchematic,baritone.api.utils.BlockOptionalMetaLookup) -> <init>
    void reset() -> a
    boolean partOfMask(int,int,int,dbq) -> b
baritone.api.schematic.RotatedSchematic -> baritone.db:
    baritone.api.schematic.ISchematic schematic -> a
    cvq rotation -> a
    cvq inverseRotation -> b
    void <init>(baritone.api.schematic.ISchematic,cvq) -> <init>
    boolean inSchematic(int,int,int,dbq) -> a
    dbq desiredState(int,int,int,dbq,java.util.List) -> a
    void reset() -> a
    int widthX() -> a
    int heightY() -> b
    int lengthZ() -> c
    boolean flipsCoordinates(cvq) -> a
    int rotateX(int,int,int,int,cvq) -> a
    int rotateZ(int,int,int,int,cvq) -> b
    dbq rotate(dbq,cvq) -> a
    dbq lambda$rotate$0(cvq,dbq) -> a
baritone.api.schematic.RotatedSchematic$1 -> baritone.dc:
    int[] $SwitchMap$net$minecraft$world$level$block$Rotation -> a
    void <clinit>() -> <clinit>
baritone.api.schematic.ShellSchematic -> baritone.dd:
    void <init>(baritone.api.schematic.ISchematic) -> <init>
    boolean partOfMask(int,int,int,dbq) -> b
baritone.api.schematic.SubstituteSchematic -> baritone.de:
    baritone.api.schematic.ISchematic schematic -> a
    java.util.Map substitutions -> a
    java.util.Map blockStateCache -> b
    void <init>(baritone.api.schematic.ISchematic,java.util.Map) -> <init>
    boolean inSchematic(int,int,int,dbq) -> a
    dbq desiredState(int,int,int,dbq,java.util.List) -> a
    dbq withBlock(dbq,cpi) -> a
    java.util.Map lambda$withBlock$0(dbq) -> a
baritone.api.schematic.WallsSchematic -> baritone.df:
    void <init>(baritone.api.schematic.ISchematic) -> <init>
    boolean partOfMask(int,int,int,dbq) -> b
baritone.api.schematic.format.ISchematicFormat -> baritone.dg:
    baritone.api.schematic.IStaticSchematic parse(java.io.InputStream) -> a
    boolean isFileType(java.io.File) -> a
    java.util.List getFileExtensions() -> a
baritone.api.schematic.mask.AbstractMask -> baritone.dh:
    int widthX -> a
    int heightY -> b
    int lengthZ -> c
    void <init>(int,int,int) -> <init>
    int widthX() -> a
    int heightY() -> b
    int lengthZ() -> c
baritone.api.schematic.mask.Mask -> baritone.di:
    boolean partOfMask$37fe1864(int,int,int) -> a
    int widthX() -> a
    int heightY() -> b
    int lengthZ() -> c
baritone.api.schematic.mask.PreComputedMask -> baritone.dj:
    boolean[][][] mask -> a
    void <init>(baritone.api.schematic.mask.StaticMask) -> <init>
    boolean partOfMask(int,int,int) -> b
baritone.api.schematic.mask.StaticMask -> baritone.dk:
    boolean partOfMask(int,int,int) -> b
    boolean partOfMask$37fe1864(int,int,int) -> a
    baritone.api.schematic.mask.StaticMask compute() -> a
baritone.api.schematic.mask.shape.CylinderMask -> baritone.dl:
    double centerA -> a
    double centerB -> b
    double radiusSqA -> c
    double radiusSqB -> d
    boolean filled -> a
    gz$a alignment -> a
    void <init>(int,int,int,boolean,gz$a) -> <init>
    boolean partOfMask(int,int,int) -> b
    boolean outside(double,double) -> a
    int getA(int,int,gz$a) -> a
    int getB(int,int,gz$a) -> b
baritone.api.schematic.mask.shape.SphereMask -> baritone.dm:
    double centerX -> a
    double centerY -> b
    double centerZ -> c
    double radiusSqX -> d
    double radiusSqY -> e
    double radiusSqZ -> f
    boolean filled -> a
    void <init>(int,int,int,boolean) -> <init>
    boolean partOfMask(int,int,int) -> b
    boolean outside(double,double,double) -> a
baritone.api.selection.ISelection -> baritone.dn:
    baritone.api.utils.BetterBlockPos pos1() -> a
    baritone.api.utils.BetterBlockPos pos2() -> b
    baritone.api.utils.BetterBlockPos min() -> c
    baritone.api.utils.BetterBlockPos max() -> d
    hy size() -> a
    ecz aabb() -> a
    baritone.api.selection.ISelection expand(gz,int) -> a
    baritone.api.selection.ISelection contract(gz,int) -> b
    baritone.api.selection.ISelection shift(gz,int) -> c
baritone.api.selection.ISelectionManager -> baritone.do:
    baritone.api.selection.ISelection addSelection(baritone.api.utils.BetterBlockPos,baritone.api.utils.BetterBlockPos) -> a
    baritone.api.selection.ISelection removeSelection(baritone.api.selection.ISelection) -> a
    baritone.api.selection.ISelection[] removeAllSelections() -> a
    baritone.api.selection.ISelection[] getSelections() -> b
    baritone.api.selection.ISelection expand(baritone.api.selection.ISelection,gz,int) -> a
    baritone.api.selection.ISelection contract(baritone.api.selection.ISelection,gz,int) -> b
    baritone.api.selection.ISelection shift(baritone.api.selection.ISelection,gz,int) -> c
baritone.api.utils.BetterBlockPos -> baritone.dp:
    baritone.api.utils.BetterBlockPos ORIGIN -> a
    int x -> a
    int y -> b
    int z -> d
    void <init>(int,int,int) -> <init>
    void <init>(double,double,double) -> <init>
    void <init>(gt) -> <init>
    baritone.api.utils.BetterBlockPos from(gt) -> a
    int hashCode() -> hashCode
    long longHash(baritone.api.utils.BetterBlockPos) -> a
    long longHash(int,int,int) -> b
    boolean equals(java.lang.Object) -> equals
    baritone.api.utils.BetterBlockPos above() -> a
    baritone.api.utils.BetterBlockPos above(int) -> a
    baritone.api.utils.BetterBlockPos below() -> b
    baritone.api.utils.BetterBlockPos below(int) -> b
    baritone.api.utils.BetterBlockPos relative(gz) -> a
    baritone.api.utils.BetterBlockPos relative(gz,int) -> a
    baritone.api.utils.BetterBlockPos north() -> c
    baritone.api.utils.BetterBlockPos north(int) -> c
    baritone.api.utils.BetterBlockPos south() -> d
    baritone.api.utils.BetterBlockPos south(int) -> d
    baritone.api.utils.BetterBlockPos east() -> e
    baritone.api.utils.BetterBlockPos east(int) -> e
    baritone.api.utils.BetterBlockPos west() -> f
    baritone.api.utils.BetterBlockPos west(int) -> f
    double distanceSq(baritone.api.utils.BetterBlockPos) -> a
    double distanceTo(baritone.api.utils.BetterBlockPos) -> b
    java.lang.String toString() -> toString
    baritone.api.utils.BetterBlockPos deserializeFromLong(long) -> a
    gt a(gz,int) -> a
    gt a(gz) -> a
    gt g(int) -> g
    gt h() -> h
    gt f(int) -> f
    gt g() -> g
    gt e(int) -> e
    gt f() -> f
    gt d(int) -> d
    gt e() -> e
    gt c(int) -> c
    gt d() -> d
    gt b(int) -> b
    gt c() -> c
    hy d(hy) -> d
    hy b(gz$a,int) -> b
    hy b(gz,int) -> b
    hy b(gz) -> b
    hy i(int) -> i
    hy k() -> k
    hy j(int) -> j
    hy l() -> l
    hy k(int) -> k
    hy m() -> m
    hy l(int) -> l
    hy n() -> n
    hy m(int) -> m
    hy o() -> o
    hy n(int) -> n
    hy p() -> p
    hy o(int) -> o
    hy e(hy) -> e
    hy f(hy) -> f
    hy c(int,int,int) -> c
    int compareTo(java.lang.Object) -> compareTo
    void <clinit>() -> <clinit>
baritone.api.utils.BlockOptionalMeta -> baritone.api.utils.BlockOptionalMeta:
    java.util.regex.Pattern PATTERN -> a
    cpi block -> a
    java.lang.String propertiesDescription -> a
    java.util.Set blockstates -> a
    java.util.Set stateHashes -> c
    java.util.Set stackHashes -> b
    dyv lootTables -> a
    dyw predicate -> a
    java.util.Map drops -> a
    java.lang.reflect.Method getVanillaServerPack -> a
    void <init>(cpi) -> <init>
    void <init>(java.lang.String) -> <init>
    java.util.Map parseProperties(cpi,java.lang.String) -> a
    java.util.Set getStates(cpi,java.util.Map) -> a
    com.google.common.collect.ImmutableSet getStateHashes(java.util.Set) -> a
    com.google.common.collect.ImmutableSet getStackHashes(java.util.Set) -> b
    boolean matches(dbq) -> a
    java.lang.String toString() -> toString
    ajy getVanillaServerPack() -> a
    dyv getManager() -> a
    dyw getPredicateManager() -> a
    java.util.List drops(cpi) -> a
    java.util.List lambda$drops$10(cpi) -> b
    void lambda$drops$9(java.util.List,cfv) -> a
    boolean lambda$getVanillaServerPack$8(java.lang.reflect.Method) -> a
    java.lang.Integer[] lambda$getStackHashes$7(int) -> a
    java.lang.Integer lambda$getStackHashes$6(cfv) -> a
    java.util.stream.Stream lambda$getStackHashes$5(dbq) -> a
    cfv lambda$getStackHashes$4(cfq) -> a
    java.lang.Integer[] lambda$getStateHashes$3(int) -> b
    boolean lambda$getStates$2(java.util.Map,dbq) -> a
    boolean lambda$getStates$1(dbq,java.util.Map$Entry) -> a
    java.lang.IllegalArgumentException lambda$parseProperties$0(java.lang.String,dcu,cpi) -> a
    void <clinit>() -> <clinit>
baritone.api.utils.BlockOptionalMeta$ServerLevelStub -> baritone.api.utils.BlockOptionalMeta$a:
    emh client -> a
    sun.misc.Unsafe unsafe -> a
    boolean $assertionsDisabled -> a
    cau G() -> G
    baritone.api.utils.BlockOptionalMeta$ServerLevelStub fastCreate() -> a
    sun.misc.Unsafe getUnsafe() -> a
    ddr I() -> I
    eel J() -> J
    eel K() -> K
    ddn a(int,int) -> a
    eec H() -> H
    void <clinit>() -> <clinit>
baritone.api.utils.BlockOptionalMetaLookup -> baritone.dq:
    com.google.common.collect.ImmutableSet blockStateSet -> a
    com.google.common.collect.ImmutableSet stackHashes -> b
    baritone.api.utils.BlockOptionalMeta[] boms -> a
    void <init>(baritone.api.utils.BlockOptionalMeta[]) -> <init>
    void <init>(cpi[]) -> <init>
    boolean has(dbq) -> a
    boolean has(cfv) -> a
    java.lang.String toString() -> toString
    baritone.api.utils.BlockOptionalMeta[] lambda$new$0(int) -> a
baritone.api.utils.BlockUtils -> baritone.dr:
    java.util.Map resourceCache -> a
    java.lang.String blockToString(cpi) -> a
    cpi stringToBlockRequired(java.lang.String) -> a
    void <clinit>() -> <clinit>
baritone.api.utils.Helper -> baritone.ds:
    baritone.api.utils.Helper HELPER -> a
    emh mc -> a
    emc MESSAGE_TAG -> a
    tj getPrefix() -> a
    void logToast(tj,tj) -> a
    void logNotification(java.lang.String,boolean) -> a_
    void logNotificationDirect(java.lang.String,boolean) -> b
    void logDebug(java.lang.String) -> a
    void logDirect(boolean,tj[]) -> a
    void logDirect(tj[]) -> a
    void logDirect(java.lang.String,n,boolean) -> a
    void logDirect(java.lang.String,n) -> a
    void logDirect(java.lang.String,boolean) -> c
    void logDirect(java.lang.String) -> b
    void logUnhandledException(java.lang.Throwable) -> a
    void lambda$logDirect$3(n,boolean,java.lang.String) -> a
    void lambda$logDirect$2(tw) -> a
    void lambda$logNotificationDirect$1(java.lang.String,boolean) -> d
    void lambda$logToast$0(tj,tj) -> b
    void <clinit>() -> <clinit>
baritone.api.utils.Helper$1 -> baritone.dt:
    void <init>() -> <init>
baritone.api.utils.IInputOverrideHandler -> baritone.du:
    void setInputForceState(baritone.api.utils.input.Input,boolean) -> a
    void clearAllKeys() -> a
baritone.api.utils.IPlayerContext -> baritone.dv:
    emh minecraft() -> a
    fhk player() -> a
    baritone.api.utils.IPlayerController playerController() -> a
    cmi world() -> a
    java.lang.Iterable entities() -> a
    java.util.stream.Stream entitiesStream() -> a
    baritone.api.cache.IWorldData worldData() -> a
    edc objectMouseOver() -> a
    baritone.api.utils.BetterBlockPos playerFeet() -> a
    ede playerFeetAsVec() -> a
    ede playerHead() -> b
    ede playerMotion() -> c
    baritone.api.utils.BetterBlockPos viewerPos() -> b
    baritone.api.utils.Rotation playerRotations() -> a
    java.util.Optional getSelectedBlock() -> a
    boolean isLookingAt(gt) -> a
baritone.api.utils.IPlayerController -> baritone.dw:
    void syncHeldItem() -> a
    boolean hasBrokenBlock() -> a
    boolean onPlayerDamageBlock(gt,gz) -> a
    void resetBlockRemoving() -> b
    void windowClick(int,int,int,cbm,bym) -> a
    cmf getGameType() -> a
    bdy processRightClickBlock$2cbe52ad(fhk,bdx,eda) -> a
    bdy processRightClick$59eb671a(fhk,bdx) -> a
    boolean clickBlock(gt,gz) -> b
    void setHittingBlock(boolean) -> a
    double getBlockReachDistance() -> a
baritone.api.utils.MyChunkPos -> baritone.api.utils.MyChunkPos:
    int x -> x
    int z -> z
    void <init>() -> <init>
    java.lang.String toString() -> toString
baritone.api.utils.NotificationHelper -> baritone.dx:
    java.awt.TrayIcon trayIcon -> a
    clp chunk -> a
    java.util.List blocks -> a
    void notify(java.lang.String,boolean) -> a
    void <init>(clp,java.util.List) -> <init>
    java.lang.Class resolveBaseClass(java.lang.reflect.Type) -> a
    int fastFloor(double) -> a
    int fastCeil(double) -> b
    int getTunnelLevel(cfv) -> a
    double getTunnelEfficiencyMultiplier(cfv) -> a
baritone.api.utils.Pair -> baritone.dy:
    java.lang.Object a -> a
    java.lang.Object b -> b
    void <init>(java.lang.Object,java.lang.Object) -> <init>
    java.lang.Object second() -> a
    boolean equals(java.lang.Object) -> equals
    int hashCode() -> hashCode
baritone.api.utils.PathCalculationResult -> baritone.dz:
    baritone.api.pathing.calc.IPath path -> a
    baritone.api.utils.PathCalculationResult$Type type -> a
    void <init>(baritone.api.utils.PathCalculationResult$Type) -> <init>
    void <init>(baritone.api.utils.PathCalculationResult$Type,baritone.api.pathing.calc.IPath) -> <init>
baritone.api.utils.PathCalculationResult$Type -> baritone.dz$a:
    baritone.api.utils.PathCalculationResult$Type SUCCESS_TO_GOAL -> a
    baritone.api.utils.PathCalculationResult$Type SUCCESS_SEGMENT -> b
    baritone.api.utils.PathCalculationResult$Type FAILURE -> c
    baritone.api.utils.PathCalculationResult$Type CANCELLATION -> d
    baritone.api.utils.PathCalculationResult$Type EXCEPTION -> e
    baritone.api.utils.PathCalculationResult$Type[] $VALUES -> a
    baritone.api.utils.PathCalculationResult$Type[] values() -> values
    baritone.api.utils.PathCalculationResult$Type valueOf(java.lang.String) -> valueOf
    void <init>(java.lang.String,int) -> <init>
    void <clinit>() -> <clinit>
baritone.api.utils.RayTraceUtils -> baritone.ea:
    vb packet -> a
    edc rayTraceTowards(bfh,baritone.api.utils.Rotation,double,boolean) -> a
    ede inferSneakingEyePosition(bfh) -> a
    void <init>(vb) -> <init>
baritone.api.utils.Rotation -> baritone.eb:
    float yaw -> a
    float pitch -> b
    void <init>(float,float) -> <init>
    baritone.api.utils.Rotation add(baritone.api.utils.Rotation) -> a
    baritone.api.utils.Rotation withPitch(float) -> a
    boolean isReallyCloseTo(baritone.api.utils.Rotation) -> a
    boolean yawIsReallyClose(baritone.api.utils.Rotation) -> b
    float normalizeYaw(float) -> a
    java.lang.String toString() -> toString
baritone.api.utils.RotationUtils -> baritone.ec:
    ede[] BLOCK_SIDE_MULTIPLIERS -> a
    baritone.api.utils.Rotation calcRotationFromVec3d(ede,ede,baritone.api.utils.Rotation) -> a
    ede calcLookDirectionFromRotation(baritone.api.utils.Rotation) -> a
    java.util.Optional reachable(baritone.api.utils.IPlayerContext,gt) -> a
    java.util.Optional reachable(baritone.api.utils.IPlayerContext,gt,boolean) -> a
    java.util.Optional reachable(baritone.api.utils.IPlayerContext,gt,double) -> a
    java.util.Optional reachable(baritone.api.utils.IPlayerContext,gt,double,boolean) -> a
    java.util.Optional reachableOffset(baritone.api.utils.IPlayerContext,gt,ede,double,boolean) -> a
    java.util.Optional reachableCenter(baritone.api.utils.IPlayerContext,gt,double,boolean) -> b
    void <clinit>() -> <clinit>
baritone.api.utils.SettingsUtil -> baritone.ed:
    java.util.regex.Pattern SETTING_PATTERN -> a
    void readAndApply(baritone.api.Settings,java.lang.String) -> a
    void save(baritone.api.Settings) -> a
    java.nio.file.Path settingsByName(java.lang.String) -> a
    java.util.List modifiedSettings(baritone.api.Settings) -> a
    java.lang.String settingTypeToString(baritone.api.Settings$Setting) -> a
    java.lang.String settingValueToString(baritone.api.Settings$Setting,java.lang.Object) -> a
    java.lang.String settingValueToString(baritone.api.Settings$Setting) -> b
    java.lang.String settingDefaultToString(baritone.api.Settings$Setting) -> c
    java.lang.String maybeCensor(int) -> a
    java.lang.String settingToString(baritone.api.Settings$Setting) -> d
    void parseAndApply(baritone.api.Settings,java.lang.String,java.lang.String) -> a
    void lambda$readAndApply$0(baritone.api.Settings,java.lang.String) -> b
    void <clinit>() -> <clinit>
baritone.api.utils.SettingsUtil$ISettingParser -> baritone.ed$a:
    java.lang.Object parse(java.lang.reflect.Type,java.lang.String) -> a
baritone.api.utils.SettingsUtil$Parser -> baritone.ed$b:
    baritone.api.utils.SettingsUtil$Parser DOUBLE -> a
    baritone.api.utils.SettingsUtil$Parser BOOLEAN -> b
    baritone.api.utils.SettingsUtil$Parser INTEGER -> c
    baritone.api.utils.SettingsUtil$Parser FLOAT -> d
    baritone.api.utils.SettingsUtil$Parser LONG -> e
    baritone.api.utils.SettingsUtil$Parser STRING -> f
    baritone.api.utils.SettingsUtil$Parser MIRROR -> g
    baritone.api.utils.SettingsUtil$Parser ROTATION -> h
    baritone.api.utils.SettingsUtil$Parser COLOR -> i
    baritone.api.utils.SettingsUtil$Parser VEC3I -> j
    baritone.api.utils.SettingsUtil$Parser BLOCK -> k
    baritone.api.utils.SettingsUtil$Parser ITEM -> l
    baritone.api.utils.SettingsUtil$Parser LIST -> m
    baritone.api.utils.SettingsUtil$Parser MAPPING -> n
    java.lang.Class cla$$ -> a
    java.util.function.Function parser -> a
    java.util.function.Function toString -> b
    baritone.api.utils.SettingsUtil$Parser[] $VALUES -> a
    baritone.api.utils.SettingsUtil$Parser[] values() -> values
    baritone.api.utils.SettingsUtil$Parser valueOf(java.lang.String) -> valueOf
    void <init>(java.lang.String,int) -> <init>
    void <init>(java.lang.String,int,java.lang.Class,java.util.function.Function) -> <init>
    void <init>(java.lang.String,int,java.lang.Class,java.util.function.Function,java.util.function.Function) -> <init>
    java.lang.Object parse(java.lang.reflect.Type,java.lang.String) -> a
    java.lang.String toString(java.lang.reflect.Type,java.lang.Object) -> a
    boolean accepts(java.lang.reflect.Type) -> a
    baritone.api.utils.SettingsUtil$Parser getParser(java.lang.reflect.Type) -> a
    boolean lambda$getParser$8(java.lang.reflect.Type,baritone.api.utils.SettingsUtil$Parser) -> a
    java.lang.String lambda$new$7(java.util.function.Function,java.lang.Object) -> a
    java.lang.String lambda$static$6(cfq) -> a
    cfq lambda$static$5(java.lang.String) -> a
    cpi lambda$static$4(java.lang.String) -> a
    java.lang.String lambda$static$3(hy) -> a
    hy lambda$static$2(java.lang.String) -> a
    java.lang.String lambda$static$1(java.awt.Color) -> a
    java.awt.Color lambda$static$0(java.lang.String) -> a
    void <clinit>() -> <clinit>
baritone.api.utils.SettingsUtil$Parser$1 -> baritone.ee:
    void <init>(java.lang.String) -> <init>
    java.lang.Object parse(java.lang.reflect.Type,java.lang.String) -> a
    java.lang.String toString(java.lang.reflect.Type,java.lang.Object) -> a
    boolean accepts(java.lang.reflect.Type) -> a
    java.lang.String lambda$toString$1(baritone.api.utils.SettingsUtil$Parser,java.lang.reflect.Type,java.lang.Object) -> a
    java.lang.Object lambda$parse$0(baritone.api.utils.SettingsUtil$Parser,java.lang.reflect.Type,java.lang.String) -> a
baritone.api.utils.SettingsUtil$Parser$2 -> baritone.ef:
    void <init>(java.lang.String) -> <init>
    java.lang.Object parse(java.lang.reflect.Type,java.lang.String) -> a
    java.lang.String toString(java.lang.reflect.Type,java.lang.Object) -> a
    boolean accepts(java.lang.reflect.Type) -> a
    java.lang.String lambda$toString$3(baritone.api.utils.SettingsUtil$Parser,java.lang.reflect.Type,baritone.api.utils.SettingsUtil$Parser,java.lang.reflect.Type,java.util.Map$Entry) -> a
    java.lang.Object lambda$parse$2(baritone.api.utils.SettingsUtil$Parser,java.lang.reflect.Type,java.lang.String[]) -> a
    java.lang.Object lambda$parse$1(baritone.api.utils.SettingsUtil$Parser,java.lang.reflect.Type,java.lang.String[]) -> b
    java.lang.String[] lambda$parse$0(java.lang.String) -> a
baritone.api.utils.VecUtils -> baritone.eg:
    baritone.api.event.events.type.EventState state -> a
    ede calculateBlockCenter(cmi,gt) -> a
    ede getBlockPosCenter(gt) -> a
    double distanceToCenter(gt,double,double,double) -> a
    double entityFlatDistanceToCenter(bfh,gt) -> a
    void <init>(baritone.api.event.events.type.EventState) -> <init>
baritone.api.utils.accessor.IItemStack -> baritone.eh:
    int getBaritoneHash() -> getBaritoneHash
baritone.api.utils.gui.BaritoneToast -> baritone.ei:
    java.lang.String title -> a
    java.lang.String subtitle -> b
    long firstDrawTime -> a
    boolean newDisplay -> a
    long totalShowTime -> b
    void <init>(tj,tj,long) -> <init>
    epy$a a(ehe,epz,long) -> a
    void addOrUpdate(tj,tj) -> a
baritone.api.utils.input.Input -> baritone.ej:
    baritone.api.utils.input.Input MOVE_FORWARD -> a
    baritone.api.utils.input.Input MOVE_BACK -> b
    baritone.api.utils.input.Input MOVE_LEFT -> c
    baritone.api.utils.input.Input MOVE_RIGHT -> d
    baritone.api.utils.input.Input CLICK_LEFT -> e
    baritone.api.utils.input.Input CLICK_RIGHT -> f
    baritone.api.utils.input.Input JUMP -> g
    baritone.api.utils.input.Input SNEAK -> h
    baritone.api.utils.input.Input SPRINT -> i
    baritone.api.utils.input.Input[] $VALUES -> a
    baritone.api.utils.input.Input[] values() -> values
    baritone.api.utils.input.Input valueOf(java.lang.String) -> valueOf
    void <init>(java.lang.String,int) -> <init>
    void <clinit>() -> <clinit>
baritone.api.utils.interfaces.IGoalRenderPos -> baritone.ek:
    gt getGoalPos() -> a
baritone.behavior.Behavior -> baritone.el:
    baritone.Baritone baritone -> a
    baritone.api.utils.IPlayerContext ctx -> a
    void <init>(baritone.Baritone) -> <init>
baritone.behavior.InventoryBehavior -> baritone.em:
    int ticksSinceLastInventoryMove -> a
    int[] lastTickRequestedMove -> a
    void <init>(baritone.Baritone) -> <init>
    void onTick(baritone.api.event.events.TickEvent) -> a
    boolean attemptToPutOnHotbar(int,java.util.function.Predicate) -> a
    boolean requestSwapWithHotBar(int,int) -> a
    int firstValidThrowaway() -> a
    boolean hasGenericThrowaway() -> a
    boolean selectThrowawayForLocation(boolean,int,int,int) -> a
    boolean throwaway(boolean,java.util.function.Predicate) -> a
    boolean throwaway(boolean,java.util.function.Predicate,boolean) -> a
    boolean lambda$selectThrowawayForLocation$3(cfq,cfv) -> a
    boolean lambda$selectThrowawayForLocation$2(dbq,cfv) -> a
    boolean lambda$selectThrowawayForLocation$1(dbq,cfv) -> b
    boolean lambda$hasGenericThrowaway$0(cfq,cfv) -> b
baritone.behavior.InventoryBehavior$1 -> baritone.en:
    void <init>(cmi,bym,bdx,cfv,eda) -> <init>
baritone.behavior.LookBehavior -> baritone.eo:
    baritone.behavior.LookBehavior$Target target -> a
    baritone.api.utils.Rotation serverRotation -> a
    baritone.api.utils.Rotation prevRotation -> b
    baritone.behavior.LookBehavior$AimProcessor processor -> a
    java.util.Deque smoothYawBuffer -> a
    java.util.Deque smoothPitchBuffer -> b
    void <init>(baritone.Baritone) -> <init>
    void updateTarget(baritone.api.utils.Rotation,boolean) -> a
    baritone.api.behavior.look.IAimProcessor getAimProcessor() -> a
    void onTick(baritone.api.event.events.TickEvent) -> a
    void onPlayerUpdate$131b5bbf(baritone.api.utils.VecUtils) -> a
    void onSendPacket$1f25927f(baritone.api.utils.RayTraceUtils) -> a
    void onWorldEvent(baritone.api.event.events.WorldEvent) -> a
    void onPlayerRotationMove(baritone.api.event.events.RotationMoveEvent) -> a
    double lambda$onPlayerUpdate$1(java.lang.Float) -> a
    double lambda$onPlayerUpdate$0(java.lang.Float) -> b
baritone.behavior.LookBehavior$1 -> baritone.ep:
    int[] $SwitchMap$baritone$api$event$events$type$EventState -> a
    void <clinit>() -> <clinit>
baritone.behavior.LookBehavior$AbstractAimProcessor -> baritone.eo$a:
    baritone.api.utils.IPlayerContext ctx -> a
    baritone.behavior.look.ForkableRandom rand -> a
    double randomYawOffset -> a
    double randomPitchOffset -> b
    void <init>(baritone.api.utils.IPlayerContext) -> <init>
    void <init>(baritone.behavior.LookBehavior$AbstractAimProcessor) -> <init>
    baritone.api.utils.Rotation peekRotation(baritone.api.utils.Rotation) -> a
    void tick() -> b
    void advance$13462e() -> a
    baritone.api.utils.Rotation nextRotation(baritone.api.utils.Rotation) -> b
    baritone.api.behavior.look.IAimProcessor fork$7002412() -> a
    baritone.api.utils.Rotation getPrevRotation() -> a
    float calculateMouseMove(float,float) -> a
    double angleToMouse(float) -> a
    float mouseToAngle(double) -> a
baritone.behavior.LookBehavior$AbstractAimProcessor$1 -> baritone.eq:
    baritone.api.utils.Rotation prev -> a
    baritone.behavior.LookBehavior$AbstractAimProcessor this$0 -> a
    void <init>(baritone.behavior.LookBehavior$AbstractAimProcessor,baritone.behavior.LookBehavior$AbstractAimProcessor) -> <init>
    baritone.api.utils.Rotation nextRotation(baritone.api.utils.Rotation) -> b
    baritone.api.utils.Rotation getPrevRotation() -> a
baritone.behavior.LookBehavior$AimProcessor -> baritone.eo$b:
    void <init>(baritone.api.utils.IPlayerContext) -> <init>
    baritone.api.utils.Rotation getPrevRotation() -> a
baritone.behavior.LookBehavior$Target -> baritone.eo$c:
    baritone.api.utils.Rotation rotation -> a
    baritone.behavior.LookBehavior$Target$Mode mode -> a
    void <init>(baritone.api.utils.Rotation,baritone.behavior.LookBehavior$Target$Mode) -> <init>
baritone.behavior.LookBehavior$Target$Mode -> baritone.eo$c$a:
    baritone.behavior.LookBehavior$Target$Mode CLIENT -> c
    baritone.behavior.LookBehavior$Target$Mode SERVER -> a
    baritone.behavior.LookBehavior$Target$Mode NONE -> b
    baritone.behavior.LookBehavior$Target$Mode[] $VALUES -> a
    baritone.behavior.LookBehavior$Target$Mode[] values() -> values
    baritone.behavior.LookBehavior$Target$Mode valueOf(java.lang.String) -> valueOf
    void <init>(java.lang.String,int) -> <init>
    baritone.behavior.LookBehavior$Target$Mode resolve(baritone.api.utils.IPlayerContext,boolean) -> a
    void <clinit>() -> <clinit>
baritone.behavior.PathingBehavior -> baritone.er:
    baritone.pathing.path.PathExecutor current -> a
    baritone.pathing.path.PathExecutor next -> b
    baritone.api.pathing.goals.Goal goal -> a
    baritone.pathing.movement.CalculationContext context -> a
    int ticksElapsedSoFar -> a
    baritone.api.utils.BetterBlockPos startPosition -> a
    boolean safeToCancel -> c
    boolean pauseRequestedLastTick -> a
    boolean unpausedLastTick -> d
    boolean pausedThisTick -> e
    boolean cancelRequested -> f
    boolean calcFailedLastTick -> b
    baritone.pathing.calc.AbstractNodeCostSearch inProgress -> a
    java.lang.Object pathCalcLock -> a
    java.lang.Object pathPlanLock -> b
    boolean lastAutoJump -> g
    baritone.api.utils.BetterBlockPos expectedSegmentStart -> b
    java.util.concurrent.LinkedBlockingQueue toDispatch -> a
    void <init>(baritone.Baritone) -> <init>
    void queuePathEvent(baritone.api.event.events.PathEvent) -> b
    void dispatchEvents() -> e
    void onTick(baritone.api.event.events.TickEvent) -> a
    void onPlayerSprintState(baritone.api.event.events.SprintStateEvent) -> a
    void onPlayerUpdate$131b5bbf(baritone.api.utils.VecUtils) -> a
    boolean secretInternalSetGoalAndPath(baritone.api.process.PathingCommand) -> a
    boolean isPathing() -> a
    boolean isSafeToCancel() -> d
    boolean cancelSegmentIfSafe() -> e
    boolean cancelEverything() -> c
    void softCancelIfSafe() -> c
    void secretInternalSegmentCancel() -> d
    void forceCancel() -> a
    java.util.Optional estimatedTicksToGoal() -> b
    void resetEstimatedTicksToGoal(baritone.api.utils.BetterBlockPos) -> a
    baritone.api.utils.BetterBlockPos pathStart() -> a
    void findPathInNewThread(gt,boolean,baritone.pathing.movement.CalculationContext) -> a
    baritone.pathing.calc.AbstractNodeCostSearch createPathfinder(gt,baritone.api.pathing.goals.Goal,baritone.api.pathing.calc.IPath,baritone.pathing.movement.CalculationContext) -> a
    void onRenderPass$493a6673(baritone.cache.ChunkPacker) -> a
    baritone.api.pathing.path.IPathExecutor getCurrent() -> a
    void lambda$findPathInNewThread$2(boolean,gt,baritone.api.pathing.goals.Goal,baritone.pathing.calc.AbstractNodeCostSearch,long,long) -> a
    baritone.pathing.path.PathExecutor lambda$findPathInNewThread$1(baritone.api.pathing.calc.IPath) -> a
    double lambda$pathStart$0(double,double,baritone.api.utils.BetterBlockPos) -> a
baritone.behavior.PathingBehavior$1 -> baritone.es:
    int[] $SwitchMap$baritone$api$event$events$type$EventState -> a
    void <clinit>() -> <clinit>
baritone.behavior.WaypointBehavior -> baritone.et:
    void <init>(baritone.Baritone) -> <init>
    void onPlayerDeath() -> d_
baritone.behavior.look.ForkableRandom -> baritone.eu:
    long[] s -> a
    void <init>() -> <init>
    void <init>(long) -> <init>
    void <init>(long[]) -> <init>
    double nextDouble() -> a
    long next() -> a
    long rotl(long,int) -> a
    long lambda$new$0(java.util.concurrent.atomic.AtomicLong) -> a
baritone.cache.CachedChunk -> baritone.ev:
    com.google.common.collect.ImmutableSet BLOCKS_TO_KEEP_TRACK_OF -> a
    int height -> d
    int size -> e
    int sizeInBytes -> a
    int x -> b
    int z -> c
    java.util.BitSet data -> a
    it.unimi.dsi.fastutil.ints.Int2ObjectOpenHashMap special -> a
    dbq[] overview -> a
    int[] heightMap -> a
    java.util.Map specialBlockLocations -> a
    long cacheTimestamp -> a
    void <init>(int,int,int,java.util.BitSet,dbq[],java.util.Map,long) -> <init>
    int size(int) -> a
    int sizeInBytes(int) -> b
    void setSpecial() -> a
    void calculateHeightMap() -> b
    java.util.ArrayList getAbsoluteBlocks(java.lang.String) -> a
    int getPositionIndex(int,int,int) -> a
    void <clinit>() -> <clinit>
baritone.cache.CachedRegion -> baritone.ew:
    baritone.cache.CachedChunk[][] chunks -> a
    int x -> a
    int z -> b
    dez dimension -> a
    boolean hasUnsavedChanges -> a
    void <init>(int,int,dez) -> <init>
    dbq getBlock(int,int,int) -> a
    boolean isCached(int,int) -> a
    java.util.ArrayList getLocationsOf(java.lang.String) -> a
    void updateCachedChunk(int,int,baritone.cache.CachedChunk) -> a
    void save(java.lang.String) -> a
    void load(java.lang.String) -> b
    void removeExpired() -> a
    baritone.cache.CachedChunk mostRecentlyModified() -> a
    java.nio.file.Path getRegionFile(java.nio.file.Path,int,int) -> a
baritone.cache.CachedWorld -> baritone.ex:
    it.unimi.dsi.fastutil.longs.Long2ObjectMap cachedRegions -> a
    java.lang.String directory -> a
    java.util.concurrent.LinkedBlockingQueue toPackQueue -> a
    java.util.Map toPackMap -> a
    dez dimension -> a
    void <init>(java.nio.file.Path,dez) -> <init>
    void queueForPacking(ddy) -> a
    boolean isCached(int,int) -> a
    java.util.ArrayList getLocationsOf(java.lang.String,int,int,int,int) -> a
    void save() -> b
    void prune() -> c
    java.util.List allRegions() -> a
    void reloadAllFromDisk() -> a
    baritone.cache.CachedRegion getRegion(int,int) -> a
    baritone.cache.CachedRegion getOrCreateRegion(int,int) -> b
    long getRegionID(int,int) -> a
    boolean isRegionInWorld(int,int) -> b
    baritone.cache.CachedRegion lambda$getOrCreateRegion$4(int,int,long) -> a
    void lambda$reloadAllFromDisk$3(baritone.cache.CachedRegion) -> a
    void lambda$save$2(baritone.cache.CachedRegion) -> b
    void lambda$save$1(baritone.cache.CachedRegion) -> c
    void lambda$new$0() -> d
baritone.cache.CachedWorld$PackerThread -> baritone.ex$a:
    baritone.cache.CachedWorld this$0 -> a
    void <init>(baritone.cache.CachedWorld) -> <init>
    void run() -> run
baritone.cache.ChunkPacker -> baritone.ey:
    float partialTicks -> a
    org.joml.Matrix4f projectionMatrix -> a
    ehe modelViewStack -> a
    baritone.cache.CachedChunk pack(ddy) -> a
    java.util.List lambda$pack$0(java.lang.String) -> a
    void <init>(float,ehe,org.joml.Matrix4f) -> <init>
baritone.cache.ChunkPacker$1 -> baritone.ez:
    int[] $SwitchMap$baritone$utils$pathing$PathingBlockType -> a
    void <clinit>() -> <clinit>
baritone.cache.FasterWorldScanner -> baritone.fa:
    baritone.cache.FasterWorldScanner INSTANCE -> a
    dbq[] PALETTE_REGISTRY_SENTINEL -> a
    baritone.cache.FasterWorldScanner[] $VALUES -> a
    boolean $assertionsDisabled -> a
    baritone.cache.FasterWorldScanner[] values() -> values
    baritone.cache.FasterWorldScanner valueOf(java.lang.String) -> valueOf
    void <init>(java.lang.String) -> <init>
    java.util.List scanChunkRadius$7fc9620e(baritone.api.utils.IPlayerContext,baritone.api.utils.BlockOptionalMetaLookup,int,int) -> a
    int repack(baritone.api.utils.IPlayerContext) -> a
    java.util.List getChunkRange(int,int,int) -> a
    java.util.List scanChunksInternal(baritone.api.utils.IPlayerContext,baritone.api.utils.BlockOptionalMetaLookup,java.util.List,int) -> a
    void visitSection(baritone.api.utils.BlockOptionalMetaLookup,ddz,java.util.List,long,long) -> a
    boolean[] getIncludedFilterIndices(baritone.api.utils.BlockOptionalMetaLookup,ded) -> a
    boolean[] getIncludedFilterIndicesFromRegistry(baritone.api.utils.BlockOptionalMetaLookup) -> a
    java.util.stream.Stream lambda$scanChunksInternal$0(baritone.api.utils.IPlayerContext,baritone.api.utils.BlockOptionalMetaLookup,clp) -> a
    void <clinit>() -> <clinit>
baritone.cache.WaypointCollection -> baritone.fb:
    java.nio.file.Path directory -> a
    java.util.Map waypoints -> a
    void <init>(java.nio.file.Path) -> <init>
    void load() -> a
    void load(baritone.api.cache.IWaypoint$Tag) -> a
    void save(baritone.api.cache.IWaypoint$Tag) -> b
    void addWaypoint(baritone.api.cache.IWaypoint) -> a
    void removeWaypoint(baritone.api.cache.IWaypoint) -> b
    java.util.Set getByTag(baritone.api.cache.IWaypoint$Tag) -> a
    java.util.Set getAllWaypoints() -> a
baritone.cache.WorldData -> baritone.fc:
    baritone.cache.CachedWorld cache -> a
    baritone.cache.WaypointCollection waypoints -> a
    void <init>(java.nio.file.Path,dez) -> <init>
    void onClose() -> a
    baritone.api.cache.ICachedWorld getCachedWorld() -> a
    baritone.api.cache.IWaypointCollection getWaypoints() -> a
    void lambda$onClose$0() -> b
baritone.cache.WorldProvider -> baritone.fd:
    java.util.Map worldCache -> a
    baritone.Baritone baritone -> a
    baritone.api.utils.IPlayerContext ctx -> a
    baritone.cache.WorldData currentWorld -> a
    cmi mcWorld -> a
    void <init>(baritone.Baritone) -> <init>
    baritone.cache.WorldData getCurrentWorld() -> a
    void initWorld(cmi) -> a
    void closeWorld() -> a
    void detectAndHandleBrokenLoading() -> b
    baritone.api.cache.IWorldData getCurrentWorld() -> a
    void lambda$initWorld$1(cmi,aqh) -> a
    baritone.cache.WorldData lambda$initWorld$0(cmi,java.nio.file.Path) -> a
    void <clinit>() -> <clinit>
baritone.command.ExampleBaritoneControl -> baritone.fe:
    baritone.api.Settings settings -> a
    baritone.api.command.manager.ICommandManager manager -> a
    void <init>(baritone.Baritone) -> <init>
    void onSendChatMessage(baritone.api.event.events.ChatEvent) -> a
    void logRanCommand(java.lang.String,java.lang.String) -> a
    boolean runCommand(java.lang.String) -> a
    void onPreTabComplete(baritone.api.event.events.TabCompleteEvent) -> a
    java.util.stream.Stream tabComplete(java.lang.String) -> a
    java.lang.String[] lambda$onPreTabComplete$1(int) -> a
    java.lang.String lambda$onPreTabComplete$0(java.lang.String,java.lang.String) -> a
    void <clinit>() -> <clinit>
baritone.command.argparser.ArgParserManager -> baritone.ff:
    baritone.command.argparser.ArgParserManager INSTANCE -> a
    baritone.api.command.registry.Registry registry -> a
    baritone.command.argparser.ArgParserManager[] $VALUES -> a
    baritone.command.argparser.ArgParserManager[] values() -> values
    baritone.command.argparser.ArgParserManager valueOf(java.lang.String) -> valueOf
    void <init>(java.lang.String) -> <init>
    java.lang.Object parseStateless(java.lang.Class,baritone.api.command.argument.ICommandArgument) -> a
    boolean lambda$getParserStateless$0(java.lang.Class,baritone.api.command.argparser.IArgParser$Stateless) -> a
    void <clinit>() -> <clinit>
baritone.command.argparser.DefaultArgParsers -> baritone.fg:
    java.util.List ALL -> a
    void <clinit>() -> <clinit>
baritone.command.argparser.DefaultArgParsers$BooleanArgumentParser -> baritone.fg$a:
    baritone.command.argparser.DefaultArgParsers$BooleanArgumentParser INSTANCE -> a
    java.util.List TRUTHY_VALUES -> a
    java.util.List FALSY_VALUES -> b
    void <init>() -> <init>
    java.lang.Class getTarget() -> a
    java.lang.Object parseArg(baritone.api.command.argument.ICommandArgument) -> a
    void <clinit>() -> <clinit>
baritone.command.argparser.DefaultArgParsers$DoubleArgumentParser -> baritone.fg$b:
    baritone.command.argparser.DefaultArgParsers$DoubleArgumentParser INSTANCE -> a
    baritone.command.argparser.DefaultArgParsers$DoubleArgumentParser[] $VALUES -> a
    baritone.command.argparser.DefaultArgParsers$DoubleArgumentParser[] values() -> values
    baritone.command.argparser.DefaultArgParsers$DoubleArgumentParser valueOf(java.lang.String) -> valueOf
    void <init>(java.lang.String) -> <init>
    java.lang.Class getTarget() -> a
    java.lang.Object parseArg(baritone.api.command.argument.ICommandArgument) -> a
    void <clinit>() -> <clinit>
baritone.command.argparser.DefaultArgParsers$FloatArgumentParser -> baritone.fg$c:
    baritone.command.argparser.DefaultArgParsers$FloatArgumentParser INSTANCE -> a
    baritone.command.argparser.DefaultArgParsers$FloatArgumentParser[] $VALUES -> a
    baritone.command.argparser.DefaultArgParsers$FloatArgumentParser[] values() -> values
    baritone.command.argparser.DefaultArgParsers$FloatArgumentParser valueOf(java.lang.String) -> valueOf
    void <init>(java.lang.String) -> <init>
    java.lang.Class getTarget() -> a
    java.lang.Object parseArg(baritone.api.command.argument.ICommandArgument) -> a
    void <clinit>() -> <clinit>
baritone.command.argparser.DefaultArgParsers$IntArgumentParser -> baritone.fg$d:
    baritone.command.argparser.DefaultArgParsers$IntArgumentParser INSTANCE -> a
    baritone.command.argparser.DefaultArgParsers$IntArgumentParser[] $VALUES -> a
    baritone.command.argparser.DefaultArgParsers$IntArgumentParser[] values() -> values
    baritone.command.argparser.DefaultArgParsers$IntArgumentParser valueOf(java.lang.String) -> valueOf
    void <init>(java.lang.String) -> <init>
    java.lang.Class getTarget() -> a
    java.lang.Object parseArg(baritone.api.command.argument.ICommandArgument) -> a
    void <clinit>() -> <clinit>
baritone.command.argparser.DefaultArgParsers$LongArgumentParser -> baritone.fg$e:
    baritone.command.argparser.DefaultArgParsers$LongArgumentParser INSTANCE -> a
    baritone.command.argparser.DefaultArgParsers$LongArgumentParser[] $VALUES -> a
    baritone.command.argparser.DefaultArgParsers$LongArgumentParser[] values() -> values
    baritone.command.argparser.DefaultArgParsers$LongArgumentParser valueOf(java.lang.String) -> valueOf
    void <init>(java.lang.String) -> <init>
    java.lang.Class getTarget() -> a
    java.lang.Object parseArg(baritone.api.command.argument.ICommandArgument) -> a
    void <clinit>() -> <clinit>
baritone.command.argument.ArgConsumer -> baritone.fh:
    baritone.api.command.manager.ICommandManager manager -> a
    baritone.api.command.datatypes.IDatatypeContext context -> a
    java.util.LinkedList args -> a
    java.util.Deque consumed -> a
    void <init>(baritone.api.command.manager.ICommandManager,java.util.Deque,java.util.Deque) -> <init>
    void <init>(baritone.api.command.manager.ICommandManager,java.util.List) -> <init>
    java.util.LinkedList getArgs() -> a
    boolean has(int) -> a
    boolean hasAny() -> a
    boolean hasAtMost(int) -> b
    boolean hasExactly(int) -> c
    boolean hasExactlyOne() -> b
    baritone.api.command.argument.ICommandArgument peek$12d00f26() -> c
    boolean is(java.lang.Class) -> a
    java.lang.String peekString() -> a
    java.lang.Object peekAsOrDefault$d36c42d(java.lang.Class,java.lang.Object) -> b
    java.lang.Object peekAsOrNull(java.lang.Class) -> a
    java.lang.Object peekDatatypeOrNull(baritone.api.command.datatypes.IDatatypeFor) -> a
    java.lang.Object peekDatatypeOrNull(baritone.api.command.datatypes.IDatatypePost) -> a
    java.lang.Object peekDatatypePostOrNull(baritone.api.command.datatypes.IDatatypePost,java.lang.Object) -> a
    baritone.api.command.argument.ICommandArgument get() -> a
    java.lang.String getString() -> b
    java.lang.Enum getEnum(java.lang.Class) -> a
    java.lang.Object getAs(java.lang.Class) -> b
    java.lang.Object getAsOrDefault(java.lang.Class,java.lang.Object) -> a
    java.lang.Object getDatatypePost(baritone.api.command.datatypes.IDatatypePost,java.lang.Object) -> b
    java.lang.Object getDatatypePostOrDefault(baritone.api.command.datatypes.IDatatypePost,java.lang.Object,java.lang.Object) -> a
    java.lang.Object getDatatypeFor(baritone.api.command.datatypes.IDatatypeFor) -> b
    java.lang.Object getDatatypeForOrDefault(baritone.api.command.datatypes.IDatatypeFor,java.lang.Object) -> a
    java.util.stream.Stream tabCompleteDatatype(baritone.api.command.datatypes.IDatatype) -> a
    java.lang.String rawRest() -> c
    void requireMin(int) -> a
    void requireMax(int) -> b
    void requireExactly(int) -> c
    baritone.api.command.argument.ICommandArgument consumed() -> b
    java.lang.String consumedString() -> d
    baritone.command.argument.ArgConsumer copy() -> a
baritone.command.argument.ArgConsumer$Context -> baritone.fh$a:
    baritone.command.argument.ArgConsumer this$0 -> a
    void <init>(baritone.command.argument.ArgConsumer) -> <init>
    baritone.api.IBaritone getBaritone() -> a
    baritone.api.command.argument.IArgConsumer getConsumer() -> a
baritone.command.argument.CommandArgument -> baritone.fi:
    int index -> a
    java.lang.String value -> a
    java.lang.String rawRest -> b
    void <init>(int,java.lang.String,java.lang.String) -> <init>
    int getIndex() -> a
    java.lang.String getValue() -> a
    java.lang.String getRawRest() -> b
    java.lang.Enum getEnum(java.lang.Class) -> a
    java.lang.Object getAs(java.lang.Class) -> a
    boolean is(java.lang.Class) -> a
    baritone.api.command.exception.CommandInvalidTypeException lambda$getEnum$1(java.lang.Class) -> a
    boolean lambda$getEnum$0(java.lang.Enum) -> a
baritone.command.argument.CommandArguments -> baritone.fj:
    java.util.regex.Pattern ARG_PATTERN -> a
    java.util.List from(java.lang.String,boolean) -> a
    baritone.command.argument.CommandArgument unknown() -> a
    void <clinit>() -> <clinit>
baritone.command.defaults.AxisCommand -> baritone.fk:
    void <init>(baritone.api.IBaritone) -> <init>
    void execute(java.lang.String,baritone.api.command.argument.IArgConsumer) -> a
    java.util.stream.Stream tabComplete$4a48d085(baritone.api.command.argument.IArgConsumer) -> a
    java.lang.String getShortDesc() -> a
    java.util.List getLongDesc() -> b
baritone.command.defaults.BlacklistCommand -> baritone.fl:
    void <init>(baritone.api.IBaritone) -> <init>
    void execute(java.lang.String,baritone.api.command.argument.IArgConsumer) -> a
    java.util.stream.Stream tabComplete$4a48d085(baritone.api.command.argument.IArgConsumer) -> a
    java.lang.String getShortDesc() -> a
    java.util.List getLongDesc() -> b
baritone.command.defaults.BuildCommand -> baritone.fm:
    java.io.File schematicsDir -> a
    void <init>(baritone.api.IBaritone) -> <init>
    void execute(java.lang.String,baritone.api.command.argument.IArgConsumer) -> a
    java.util.stream.Stream tabComplete$4a48d085(baritone.api.command.argument.IArgConsumer) -> a
    java.lang.String getShortDesc() -> a
    java.util.List getLongDesc() -> b
baritone.command.defaults.ClickCommand -> baritone.fn:
    void <init>(baritone.api.IBaritone) -> <init>
    void execute(java.lang.String,baritone.api.command.argument.IArgConsumer) -> a
    java.util.stream.Stream tabComplete$4a48d085(baritone.api.command.argument.IArgConsumer) -> a
    java.lang.String getShortDesc() -> a
    java.util.List getLongDesc() -> b
baritone.command.defaults.ComeCommand -> baritone.fo:
    void <init>(baritone.api.IBaritone) -> <init>
    void execute(java.lang.String,baritone.api.command.argument.IArgConsumer) -> a
    java.util.stream.Stream tabComplete$4a48d085(baritone.api.command.argument.IArgConsumer) -> a
    java.lang.String getShortDesc() -> a
    java.util.List getLongDesc() -> b
baritone.command.defaults.CommandAlias -> baritone.fp:
    java.lang.String shortDesc -> a
    java.lang.String target -> b
    void <init>(baritone.api.IBaritone,java.util.List,java.lang.String,java.lang.String) -> <init>
    void <init>(baritone.api.IBaritone,java.lang.String,java.lang.String,java.lang.String) -> <init>
    void execute(java.lang.String,baritone.api.command.argument.IArgConsumer) -> a
    java.util.stream.Stream tabComplete$4a48d085(baritone.api.command.argument.IArgConsumer) -> a
    java.lang.String getShortDesc() -> a
    java.util.List getLongDesc() -> b
baritone.command.defaults.ETACommand -> baritone.fq:
    void <init>(baritone.api.IBaritone) -> <init>
    void execute(java.lang.String,baritone.api.command.argument.IArgConsumer) -> a
    java.util.stream.Stream tabComplete$4a48d085(baritone.api.command.argument.IArgConsumer) -> a
    java.lang.String getShortDesc() -> a
    java.util.List getLongDesc() -> b
baritone.command.defaults.ElytraCommand -> baritone.fr:
    void <init>(baritone.api.IBaritone) -> <init>
    void execute(java.lang.String,baritone.api.command.argument.IArgConsumer) -> a
    tj suggest2b2tSeeds() -> b
    boolean detectOn2b2t() -> a
    java.util.stream.Stream tabComplete$4a48d085(baritone.api.command.argument.IArgConsumer) -> a
    java.lang.String getShortDesc() -> a
    java.util.List getLongDesc() -> b
    java.lang.String unsupportedSystemMessage() -> b
baritone.command.defaults.ExecutionControlCommands -> baritone.fs:
    baritone.api.command.Command pauseCommand -> a
    baritone.api.command.Command resumeCommand -> b
    baritone.api.command.Command pausedCommand -> c
    baritone.api.command.Command cancelCommand -> d
    void <init>(baritone.api.IBaritone) -> <init>
baritone.command.defaults.ExecutionControlCommands$1 -> baritone.ft:
    boolean[] val$paused -> a
    baritone.api.IBaritone val$baritone -> a
    void <init>(boolean[],baritone.api.IBaritone) -> <init>
    boolean isActive() -> a
    baritone.api.process.PathingCommand onTick(boolean,boolean) -> a
    boolean isTemporary() -> b
    void onLostControl() -> a
    double priority() -> a
    java.lang.String displayName0() -> b
baritone.command.defaults.ExecutionControlCommands$2 -> baritone.fu:
    boolean[] val$paused -> a
    void <init>(baritone.api.IBaritone,java.lang.String[],boolean[]) -> <init>
    void execute(java.lang.String,baritone.api.command.argument.IArgConsumer) -> a
    java.util.stream.Stream tabComplete$4a48d085(baritone.api.command.argument.IArgConsumer) -> a
    java.lang.String getShortDesc() -> a
    java.util.List getLongDesc() -> b
baritone.command.defaults.ExecutionControlCommands$3 -> baritone.fv:
    boolean[] val$paused -> a
    void <init>(baritone.api.IBaritone,java.lang.String[],boolean[]) -> <init>
    void execute(java.lang.String,baritone.api.command.argument.IArgConsumer) -> a
    java.util.stream.Stream tabComplete$4a48d085(baritone.api.command.argument.IArgConsumer) -> a
    java.lang.String getShortDesc() -> a
    java.util.List getLongDesc() -> b
baritone.command.defaults.ExecutionControlCommands$4 -> baritone.fw:
    boolean[] val$paused -> a
    void <init>(baritone.api.IBaritone,java.lang.String[],boolean[]) -> <init>
    void execute(java.lang.String,baritone.api.command.argument.IArgConsumer) -> a
    java.util.stream.Stream tabComplete$4a48d085(baritone.api.command.argument.IArgConsumer) -> a
    java.lang.String getShortDesc() -> a
    java.util.List getLongDesc() -> b
baritone.command.defaults.ExecutionControlCommands$5 -> baritone.fx:
    boolean[] val$paused -> a
    void <init>(baritone.api.IBaritone,java.lang.String[],boolean[]) -> <init>
    void execute(java.lang.String,baritone.api.command.argument.IArgConsumer) -> a
    java.util.stream.Stream tabComplete$4a48d085(baritone.api.command.argument.IArgConsumer) -> a
    java.lang.String getShortDesc() -> a
    java.util.List getLongDesc() -> b
baritone.command.defaults.ExploreCommand -> baritone.fy:
    void <init>(baritone.api.IBaritone) -> <init>
    void execute(java.lang.String,baritone.api.command.argument.IArgConsumer) -> a
    java.util.stream.Stream tabComplete$4a48d085(baritone.api.command.argument.IArgConsumer) -> a
    java.lang.String getShortDesc() -> a
    java.util.List getLongDesc() -> b
baritone.command.defaults.ExploreFilterCommand -> baritone.fz:
    void <init>(baritone.api.IBaritone) -> <init>
    void execute(java.lang.String,baritone.api.command.argument.IArgConsumer) -> a
    java.util.stream.Stream tabComplete$4a48d085(baritone.api.command.argument.IArgConsumer) -> a
    java.lang.String getShortDesc() -> a
    java.util.List getLongDesc() -> b
baritone.command.defaults.FarmCommand -> baritone.ga:
    void <init>(baritone.api.IBaritone) -> <init>
    void execute(java.lang.String,baritone.api.command.argument.IArgConsumer) -> a
    java.util.stream.Stream tabComplete$4a48d085(baritone.api.command.argument.IArgConsumer) -> a
    java.lang.String getShortDesc() -> a
    java.util.List getLongDesc() -> b
baritone.command.defaults.FindCommand -> baritone.gb:
    void <init>(baritone.api.IBaritone) -> <init>
    void execute(java.lang.String,baritone.api.command.argument.IArgConsumer) -> a
    tj positionToComponent(baritone.api.utils.BetterBlockPos) -> a
    java.util.stream.Stream tabComplete$4a48d085(baritone.api.command.argument.IArgConsumer) -> a
    java.lang.String getShortDesc() -> a
    java.util.List getLongDesc() -> b
    void lambda$execute$2(baritone.command.defaults.FindCommand,tj) -> a
    tj[] lambda$execute$1(int) -> a
    java.util.stream.Stream lambda$execute$0(baritone.api.utils.BetterBlockPos,cpi) -> a
baritone.command.defaults.FollowCommand -> baritone.command.defaults.FollowCommand:
    void <init>(baritone.api.IBaritone) -> <init>
    void execute(java.lang.String,baritone.api.command.argument.IArgConsumer) -> a
    java.util.stream.Stream tabComplete$4a48d085(baritone.api.command.argument.IArgConsumer) -> a
    java.lang.String getShortDesc() -> a
    java.util.List getLongDesc() -> b
    boolean lambda$execute$1(java.util.List,bfh) -> a
    boolean lambda$execute$0(bfh,bfl) -> a
baritone.command.defaults.FollowCommand$FollowGroup -> baritone.command.defaults.FollowCommand$FollowGroup:
    baritone.command.defaults.FollowCommand$FollowGroup ENTITIES -> a
    baritone.command.defaults.FollowCommand$FollowGroup PLAYERS -> b
    java.util.function.Predicate filter -> a
    baritone.command.defaults.FollowCommand$FollowGroup[] $VALUES -> a
    baritone.command.defaults.FollowCommand$FollowGroup[] values() -> values
    baritone.command.defaults.FollowCommand$FollowGroup valueOf(java.lang.String) -> valueOf
    void <init>(java.lang.String,int,java.util.function.Predicate) -> <init>
    void <clinit>() -> <clinit>
baritone.command.defaults.FollowCommand$FollowList -> baritone.command.defaults.FollowCommand$FollowList:
    baritone.command.defaults.FollowCommand$FollowList ENTITY -> a
    baritone.command.defaults.FollowCommand$FollowList PLAYER -> b
    baritone.api.command.datatypes.IDatatypeFor datatype -> a
    baritone.command.defaults.FollowCommand$FollowList[] $VALUES -> a
    baritone.command.defaults.FollowCommand$FollowList[] values() -> values
    baritone.command.defaults.FollowCommand$FollowList valueOf(java.lang.String) -> valueOf
    void <init>(java.lang.String,int,baritone.api.command.datatypes.IDatatypeFor) -> <init>
    void <clinit>() -> <clinit>
baritone.command.defaults.FollowCommand$NoEntitiesException -> baritone.command.defaults.FollowCommand$a:
    void <init>() -> <init>
    void <init>(java.lang.String) -> <init>
    void <init>(int) -> <init>
baritone.command.defaults.ForceCancelCommand -> baritone.gc:
    void <init>(baritone.api.IBaritone) -> <init>
    void execute(java.lang.String,baritone.api.command.argument.IArgConsumer) -> a
    java.util.stream.Stream tabComplete$4a48d085(baritone.api.command.argument.IArgConsumer) -> a
    java.lang.String getShortDesc() -> a
    java.util.List getLongDesc() -> b
baritone.command.defaults.GcCommand -> baritone.gd:
    void <init>(baritone.api.IBaritone) -> <init>
    void execute(java.lang.String,baritone.api.command.argument.IArgConsumer) -> a
    java.util.stream.Stream tabComplete$4a48d085(baritone.api.command.argument.IArgConsumer) -> a
    java.lang.String getShortDesc() -> a
    java.util.List getLongDesc() -> b
baritone.command.defaults.GoalCommand -> baritone.ge:
    void <init>(baritone.api.IBaritone) -> <init>
    void execute(java.lang.String,baritone.api.command.argument.IArgConsumer) -> a
    java.util.stream.Stream tabComplete$4a48d085(baritone.api.command.argument.IArgConsumer) -> a
    java.lang.String getShortDesc() -> a
    java.util.List getLongDesc() -> b
baritone.command.defaults.GotoCommand -> baritone.gf:
    void <init>(baritone.api.IBaritone) -> <init>
    void execute(java.lang.String,baritone.api.command.argument.IArgConsumer) -> a
    java.util.stream.Stream tabComplete$4a48d085(baritone.api.command.argument.IArgConsumer) -> a
    java.lang.String getShortDesc() -> a
    java.util.List getLongDesc() -> b
baritone.command.defaults.HelpCommand -> baritone.gg:
    void <init>(baritone.api.IBaritone) -> <init>
    void execute(java.lang.String,baritone.api.command.argument.IArgConsumer) -> a
    java.util.stream.Stream tabComplete$4a48d085(baritone.api.command.argument.IArgConsumer) -> a
    java.lang.String getShortDesc() -> a
    java.util.List getLongDesc() -> b
    tj lambda$execute$2(java.lang.String,baritone.api.command.ICommand) -> a
    void lambda$execute$1() -> a
    boolean lambda$execute$0(baritone.api.command.ICommand) -> a
baritone.command.defaults.InvertCommand -> baritone.gh:
    void <init>(baritone.api.IBaritone) -> <init>
    void execute(java.lang.String,baritone.api.command.argument.IArgConsumer) -> a
    java.util.stream.Stream tabComplete$4a48d085(baritone.api.command.argument.IArgConsumer) -> a
    java.lang.String getShortDesc() -> a
    java.util.List getLongDesc() -> b
baritone.command.defaults.LitematicaCommand -> baritone.gi:
    void <init>(baritone.api.IBaritone) -> <init>
    void execute(java.lang.String,baritone.api.command.argument.IArgConsumer) -> a
    java.util.stream.Stream tabComplete$4a48d085(baritone.api.command.argument.IArgConsumer) -> a
    java.lang.String getShortDesc() -> a
    java.util.List getLongDesc() -> b
baritone.command.defaults.MineCommand -> baritone.gj:
    void <init>(baritone.api.IBaritone) -> <init>
    void execute(java.lang.String,baritone.api.command.argument.IArgConsumer) -> a
    java.util.stream.Stream tabComplete$4a48d085(baritone.api.command.argument.IArgConsumer) -> a
    java.lang.String getShortDesc() -> a
    java.util.List getLongDesc() -> b
baritone.command.defaults.PathCommand -> baritone.gk:
    void <init>(baritone.api.IBaritone) -> <init>
    void execute(java.lang.String,baritone.api.command.argument.IArgConsumer) -> a
    java.util.stream.Stream tabComplete$4a48d085(baritone.api.command.argument.IArgConsumer) -> a
    java.lang.String getShortDesc() -> a
    java.util.List getLongDesc() -> b
baritone.command.defaults.PickupCommand -> baritone.gl:
    void <init>(baritone.api.IBaritone) -> <init>
    void execute(java.lang.String,baritone.api.command.argument.IArgConsumer) -> a
    java.util.stream.Stream tabComplete$4a48d085(baritone.api.command.argument.IArgConsumer) -> a
    java.lang.String getShortDesc() -> a
    java.util.List getLongDesc() -> b
    boolean lambda$execute$1(java.util.Set,cfv) -> a
    boolean lambda$execute$0(cfv) -> a
baritone.command.defaults.ProcCommand -> baritone.gm:
    void <init>(baritone.api.IBaritone) -> <init>
    void execute(java.lang.String,baritone.api.command.argument.IArgConsumer) -> a
    java.util.stream.Stream tabComplete$4a48d085(baritone.api.command.argument.IArgConsumer) -> a
    java.lang.String getShortDesc() -> a
    java.util.List getLongDesc() -> b
baritone.command.defaults.ReloadAllCommand -> baritone.gn:
    void <init>(baritone.api.IBaritone) -> <init>
    void execute(java.lang.String,baritone.api.command.argument.IArgConsumer) -> a
    java.util.stream.Stream tabComplete$4a48d085(baritone.api.command.argument.IArgConsumer) -> a
    java.lang.String getShortDesc() -> a
    java.util.List getLongDesc() -> b
baritone.command.defaults.RenderCommand -> baritone.go:
    void <init>(baritone.api.IBaritone) -> <init>
    void execute(java.lang.String,baritone.api.command.argument.IArgConsumer) -> a
    java.util.stream.Stream tabComplete$4a48d085(baritone.api.command.argument.IArgConsumer) -> a
    java.lang.String getShortDesc() -> a
    java.util.List getLongDesc() -> b
baritone.command.defaults.RepackCommand -> baritone.gp:
    void <init>(baritone.api.IBaritone) -> <init>
    void execute(java.lang.String,baritone.api.command.argument.IArgConsumer) -> a
    java.util.stream.Stream tabComplete$4a48d085(baritone.api.command.argument.IArgConsumer) -> a
    java.lang.String getShortDesc() -> a
    java.util.List getLongDesc() -> b
baritone.command.defaults.SaveAllCommand -> baritone.gq:
    void <init>(baritone.api.IBaritone) -> <init>
    void execute(java.lang.String,baritone.api.command.argument.IArgConsumer) -> a
    java.util.stream.Stream tabComplete$4a48d085(baritone.api.command.argument.IArgConsumer) -> a
    java.lang.String getShortDesc() -> a
    java.util.List getLongDesc() -> b
baritone.command.defaults.SelCommand -> baritone.gr:
    baritone.api.selection.ISelectionManager manager -> a
    baritone.api.utils.BetterBlockPos pos1 -> a
    baritone.api.schematic.ISchematic clipboard -> a
    hy clipboardOffset -> a
    void <init>(baritone.api.IBaritone) -> <init>
    void execute(java.lang.String,baritone.api.command.argument.IArgConsumer) -> a
    java.util.stream.Stream tabComplete$4a48d085(baritone.api.command.argument.IArgConsumer) -> a
    java.lang.String getShortDesc() -> a
    java.util.List getLongDesc() -> b
    baritone.api.schematic.ISchematic lambda$execute$0(baritone.command.defaults.SelCommand$Action,baritone.api.utils.BlockOptionalMetaLookup,gz$a,baritone.api.schematic.ISchematic) -> a
baritone.command.defaults.SelCommand$1 -> baritone.gs:
    baritone.command.defaults.SelCommand this$0 -> a
    void <init>(baritone.command.defaults.SelCommand) -> <init>
    void onRenderPass$493a6673(baritone.cache.ChunkPacker) -> a
baritone.command.defaults.SelCommand$2 -> baritone.gt:
    int[] $SwitchMap$baritone$command$defaults$SelCommand$Action -> a
    void <clinit>() -> <clinit>
baritone.command.defaults.SelCommand$Action -> baritone.gr$a:
    baritone.command.defaults.SelCommand$Action POS1 -> a
    baritone.command.defaults.SelCommand$Action POS2 -> b
    baritone.command.defaults.SelCommand$Action CLEAR -> c
    baritone.command.defaults.SelCommand$Action UNDO -> d
    baritone.command.defaults.SelCommand$Action SET -> r
    baritone.command.defaults.SelCommand$Action WALLS -> e
    baritone.command.defaults.SelCommand$Action SHELL -> f
    baritone.command.defaults.SelCommand$Action SPHERE -> g
    baritone.command.defaults.SelCommand$Action HSPHERE -> h
    baritone.command.defaults.SelCommand$Action CYLINDER -> i
    baritone.command.defaults.SelCommand$Action HCYLINDER -> j
    baritone.command.defaults.SelCommand$Action CLEARAREA -> k
    baritone.command.defaults.SelCommand$Action REPLACE -> l
    baritone.command.defaults.SelCommand$Action EXPAND -> m
    baritone.command.defaults.SelCommand$Action COPY -> n
    baritone.command.defaults.SelCommand$Action PASTE -> o
    baritone.command.defaults.SelCommand$Action CONTRACT -> p
    baritone.command.defaults.SelCommand$Action SHIFT -> q
    java.lang.String[] names -> a
    baritone.command.defaults.SelCommand$Action[] $VALUES -> a
    baritone.command.defaults.SelCommand$Action[] values() -> values
    baritone.command.defaults.SelCommand$Action valueOf(java.lang.String) -> valueOf
    void <init>(java.lang.String,int,java.lang.String[]) -> <init>
    baritone.command.defaults.SelCommand$Action getByName(java.lang.String) -> a
    java.lang.String[] getAllNames() -> a
    boolean isFillAction() -> a
    void <clinit>() -> <clinit>
baritone.command.defaults.SelCommand$TransformTarget -> baritone.gr$b:
    baritone.command.defaults.SelCommand$TransformTarget ALL -> a
    baritone.command.defaults.SelCommand$TransformTarget NEWEST -> b
    baritone.command.defaults.SelCommand$TransformTarget OLDEST -> c
    java.util.function.Function transform -> a
    java.lang.String[] names -> a
    baritone.command.defaults.SelCommand$TransformTarget[] $VALUES -> a
    baritone.command.defaults.SelCommand$TransformTarget[] values() -> values
    baritone.command.defaults.SelCommand$TransformTarget valueOf(java.lang.String) -> valueOf
    void <init>(java.lang.String,int,java.util.function.Function,java.lang.String[]) -> <init>
    baritone.command.defaults.SelCommand$TransformTarget getByName(java.lang.String) -> a
    java.lang.String[] getAllNames() -> a
    baritone.api.selection.ISelection[] lambda$static$2(baritone.api.selection.ISelection[]) -> a
    baritone.api.selection.ISelection[] lambda$static$1(baritone.api.selection.ISelection[]) -> b
    baritone.api.selection.ISelection[] lambda$static$0(baritone.api.selection.ISelection[]) -> c
    void <clinit>() -> <clinit>
baritone.command.defaults.SetCommand -> baritone.gu:
    void <init>(baritone.api.IBaritone) -> <init>
    void execute(java.lang.String,baritone.api.command.argument.IArgConsumer) -> a
    java.util.stream.Stream tabComplete$4a48d085(baritone.api.command.argument.IArgConsumer) -> a
    java.lang.String getShortDesc() -> a
    java.util.List getLongDesc() -> b
    boolean lambda$execute$5(java.lang.String,baritone.api.Settings$Setting) -> a
    tj lambda$execute$4(baritone.api.Settings$Setting) -> a
    void lambda$execute$3(java.lang.String,boolean) -> d
    int lambda$execute$2(baritone.api.Settings$Setting,baritone.api.Settings$Setting) -> a
    boolean lambda$execute$1(java.lang.String,baritone.api.Settings$Setting) -> b
    boolean lambda$execute$0(baritone.api.Settings$Setting) -> a
baritone.command.defaults.SurfaceCommand -> baritone.gv:
    void <init>(baritone.api.IBaritone) -> <init>
    void execute(java.lang.String,baritone.api.command.argument.IArgConsumer) -> a
    java.util.stream.Stream tabComplete$4a48d085(baritone.api.command.argument.IArgConsumer) -> a
    java.lang.String getShortDesc() -> a
    java.util.List getLongDesc() -> b
baritone.command.defaults.ThisWayCommand -> baritone.gw:
    void <init>(baritone.api.IBaritone) -> <init>
    void execute(java.lang.String,baritone.api.command.argument.IArgConsumer) -> a
    java.util.stream.Stream tabComplete$4a48d085(baritone.api.command.argument.IArgConsumer) -> a
    java.lang.String getShortDesc() -> a
    java.util.List getLongDesc() -> b
baritone.command.defaults.TunnelCommand -> baritone.gx:
    void <init>(baritone.api.IBaritone) -> <init>
    void execute(java.lang.String,baritone.api.command.argument.IArgConsumer) -> a
    java.util.stream.Stream tabComplete$4a48d085(baritone.api.command.argument.IArgConsumer) -> a
    java.lang.String getShortDesc() -> a
    java.util.List getLongDesc() -> b
baritone.command.defaults.TunnelCommand$1 -> baritone.gy:
    int[] $SwitchMap$net$minecraft$core$Direction -> a
    void <clinit>() -> <clinit>
baritone.command.defaults.VersionCommand -> baritone.gz:
    void <init>(baritone.api.IBaritone) -> <init>
    void execute(java.lang.String,baritone.api.command.argument.IArgConsumer) -> a
    java.util.stream.Stream tabComplete$4a48d085(baritone.api.command.argument.IArgConsumer) -> a
    java.lang.String getShortDesc() -> a
    java.util.List getLongDesc() -> b
baritone.command.defaults.WaypointsCommand -> baritone.ha:
    java.util.Map deletedWaypoints -> a
    void <init>(baritone.api.IBaritone) -> <init>
    void execute(java.lang.String,baritone.api.command.argument.IArgConsumer) -> a
    java.util.stream.Stream tabComplete$4a48d085(baritone.api.command.argument.IArgConsumer) -> a
    java.lang.String getShortDesc() -> a
    java.util.List getLongDesc() -> b
    java.util.List lambda$execute$6(baritone.api.cache.IWorldData) -> a
    void lambda$execute$5() -> a
    java.lang.String lambda$execute$4(baritone.api.cache.IWaypoint) -> a
    java.util.List lambda$execute$3(baritone.api.cache.IWorldData) -> b
    void lambda$execute$2(baritone.api.cache.IWaypoint$Tag) -> a
    tj lambda$execute$1(java.util.function.BiFunction,baritone.command.defaults.WaypointsCommand$Action,baritone.api.cache.IWaypoint) -> a
    tj lambda$execute$0(java.lang.String,baritone.api.cache.IWaypoint,baritone.command.defaults.WaypointsCommand$Action) -> a
baritone.command.defaults.WaypointsCommand$Action -> baritone.ha$a:
    baritone.command.defaults.WaypointsCommand$Action LIST -> a
    baritone.command.defaults.WaypointsCommand$Action CLEAR -> b
    baritone.command.defaults.WaypointsCommand$Action SAVE -> c
    baritone.command.defaults.WaypointsCommand$Action INFO -> d
    baritone.command.defaults.WaypointsCommand$Action DELETE -> e
    baritone.command.defaults.WaypointsCommand$Action RESTORE -> f
    baritone.command.defaults.WaypointsCommand$Action GOAL -> g
    baritone.command.defaults.WaypointsCommand$Action GOTO -> h
    java.lang.String[] names -> a
    baritone.command.defaults.WaypointsCommand$Action[] $VALUES -> a
    baritone.command.defaults.WaypointsCommand$Action[] values() -> values
    baritone.command.defaults.WaypointsCommand$Action valueOf(java.lang.String) -> valueOf
    void <init>(java.lang.String,int,java.lang.String[]) -> <init>
    baritone.command.defaults.WaypointsCommand$Action getByName(java.lang.String) -> a
    java.lang.String[] getAllNames() -> a
    void <clinit>() -> <clinit>
baritone.command.manager.CommandManager -> baritone.hb:
    baritone.api.command.registry.Registry registry -> a
    baritone.Baritone baritone -> a
    void <init>(baritone.Baritone) -> <init>
    baritone.api.IBaritone getBaritone() -> a
    baritone.api.command.registry.Registry getRegistry() -> a
    baritone.api.command.ICommand getCommand(java.lang.String) -> a
    boolean execute(java.lang.String) -> a
    boolean execute(aqh) -> a
    java.util.stream.Stream tabComplete(java.lang.String) -> a
    baritone.command.manager.CommandManager$ExecutionWrapper from(aqh) -> a
    aqh expand(java.lang.String,boolean) -> a
baritone.command.manager.CommandManager$ExecutionWrapper -> baritone.hb$a:
    baritone.api.command.ICommand command -> a
    java.lang.String label -> a
    baritone.command.argument.ArgConsumer args -> a
    void <init>(baritone.api.command.ICommand,java.lang.String,baritone.command.argument.ArgConsumer) -> <init>
    void execute() -> a
    java.util.stream.Stream tabComplete() -> a
baritone.event.GameEventHandler -> baritone.hc:
    baritone.Baritone baritone -> a
    java.util.List listeners -> a
    void <init>(baritone.Baritone) -> <init>
    void onTick(baritone.api.event.events.TickEvent) -> a
    void onPostTick(baritone.api.event.events.TickEvent) -> b
    void onPlayerUpdate$131b5bbf(baritone.api.utils.VecUtils) -> a
    void onSendChatMessage(baritone.api.event.events.ChatEvent) -> a
    void onPreTabComplete(baritone.api.event.events.TabCompleteEvent) -> a
    void onChunkEvent(baritone.api.event.events.ChunkEvent) -> a
    void onBlockChange$4a8de162(baritone.api.utils.NotificationHelper) -> a
    void onRenderPass$493a6673(baritone.cache.ChunkPacker) -> a
    void onWorldEvent(baritone.api.event.events.WorldEvent) -> a
    void onSendPacket$1f25927f(baritone.api.utils.RayTraceUtils) -> a
    void onReceivePacket$1f25927f(baritone.api.utils.RayTraceUtils) -> b
    void onPlayerRotationMove(baritone.api.event.events.RotationMoveEvent) -> a
    void onPlayerSprintState(baritone.api.event.events.SprintStateEvent) -> a
    void onPlayerDeath() -> d_
    void onPathEvent(baritone.api.event.events.PathEvent) -> a
    void registerEventListener(baritone.api.event.listener.IGameEventListener) -> a
    void lambda$onPathEvent$16(baritone.api.event.events.PathEvent,baritone.api.event.listener.IGameEventListener) -> a
    void lambda$onPlayerSprintState$14(baritone.api.event.events.SprintStateEvent,baritone.api.event.listener.IGameEventListener) -> a
    void lambda$onPlayerRotationMove$13(baritone.api.event.events.RotationMoveEvent,baritone.api.event.listener.IGameEventListener) -> a
    void lambda$onReceivePacket$12$69ed122f(baritone.api.utils.RayTraceUtils,baritone.api.event.listener.IGameEventListener) -> a
    void lambda$onSendPacket$11$69ed122f(baritone.api.utils.RayTraceUtils,baritone.api.event.listener.IGameEventListener) -> b
    void lambda$onWorldEvent$10(baritone.api.event.events.WorldEvent,baritone.api.event.listener.IGameEventListener) -> a
    void lambda$onRenderPass$9$2a6f60df(baritone.cache.ChunkPacker,baritone.api.event.listener.IGameEventListener) -> a
    void lambda$onBlockChange$8$2a95354c(baritone.api.utils.NotificationHelper,baritone.api.event.listener.IGameEventListener) -> a
    void lambda$onBlockChange$7$5f760443(baritone.api.utils.NotificationHelper,baritone.api.cache.IWorldData) -> a
    void lambda$onChunkEvent$6(baritone.api.event.events.ChunkEvent,baritone.api.event.listener.IGameEventListener) -> a
    void lambda$onChunkEvent$5(cmi,baritone.api.event.events.ChunkEvent,baritone.api.cache.IWorldData) -> a
    void lambda$onPreTabComplete$4(baritone.api.event.events.TabCompleteEvent,baritone.api.event.listener.IGameEventListener) -> a
    void lambda$onSendChatMessage$3(baritone.api.event.events.ChatEvent,baritone.api.event.listener.IGameEventListener) -> a
    void lambda$onPlayerUpdate$2$1352b393(baritone.api.utils.VecUtils,baritone.api.event.listener.IGameEventListener) -> a
    void lambda$onPostTick$1(baritone.api.event.events.TickEvent,baritone.api.event.listener.IGameEventListener) -> a
    void lambda$onTick$0(baritone.api.event.events.TickEvent,baritone.api.event.listener.IGameEventListener) -> b
baritone.launch.BaritoneMixinConnector -> baritone.launch.BaritoneMixinConnector:
    void <init>() -> <init>
    void connect() -> connect
baritone.launch.LaunchTesting -> baritone.launch.LaunchTesting:
    void <init>() -> <init>
    void main(java.lang.String[]) -> main
    void hackNatives() -> hackNatives
    void attemptLogin(java.util.Map,java.lang.String,java.lang.String) -> attemptLogin
    void lambda$main$0(java.util.List,java.lang.String,java.lang.String) -> lambda$main$0
baritone.launch.mixins.MixinChunkArray -> baritone.launch.mixins.MixinChunkArray:
    java.util.concurrent.atomic.AtomicReferenceArray b -> b
    int c -> c
    int d -> d
    int e -> e
    int f -> f
    int g -> g
    void <init>() -> <init>
    boolean b(int,int) -> b
    int a(int,int) -> a
    void a(int,ddy) -> a
    int centerX() -> centerX
    int centerZ() -> centerZ
    int viewDistance() -> viewDistance
    java.util.concurrent.atomic.AtomicReferenceArray getChunks() -> getChunks
    void copyFrom(baritone.utils.accessor.IChunkArray) -> copyFrom
baritone.launch.mixins.MixinClientChunkProvider -> baritone.launch.mixins.MixinClientChunkProvider:
    fdj e -> e
    void <init>() -> <init>
    fdh createThreadSafeCopy() -> createThreadSafeCopy
    baritone.utils.accessor.IChunkArray extractReferenceArray() -> extractReferenceArray
baritone.launch.mixins.MixinClientPlayNetHandler -> baritone.launch.mixins.MixinClientPlayNetHandler:
    emh m -> m
    void <init>() -> <init>
    void sendChatMessage(java.lang.String,org.spongepowered.asm.mixin.injection.callback.CallbackInfo) -> sendChatMessage
    void postHandleChunkData(wq,org.spongepowered.asm.mixin.injection.callback.CallbackInfo) -> postHandleChunkData
    void preChunkUnload(wj,org.spongepowered.asm.mixin.injection.callback.CallbackInfo) -> preChunkUnload
    void postChunkUnload(wj,org.spongepowered.asm.mixin.injection.callback.CallbackInfo) -> postChunkUnload
    void postHandleBlockChange(vo,org.spongepowered.asm.mixin.injection.callback.CallbackInfo) -> postHandleBlockChange
    void postHandleMultiBlockChange(xu,org.spongepowered.asm.mixin.injection.callback.CallbackInfo) -> postHandleMultiBlockChange
    void onPlayerDeath(xj,org.spongepowered.asm.mixin.injection.callback.CallbackInfo) -> onPlayerDeath
    void lambda$postHandleMultiBlockChange$0(java.util.List,gt,dbq) -> lambda$postHandleMultiBlockChange$0
baritone.launch.mixins.MixinClientPlayerEntity -> baritone.launch.mixins.MixinClientPlayerEntity:
    void <init>() -> <init>
    void onPreUpdate(org.spongepowered.asm.mixin.injection.callback.CallbackInfo) -> onPreUpdate
    boolean isAllowFlying(byj) -> isAllowFlying
    boolean isKeyDown(emf) -> isKeyDown
    void updateRidden(org.spongepowered.asm.mixin.injection.callback.CallbackInfo) -> updateRidden
    boolean tryToStartFallFlying(fhk) -> tryToStartFallFlying
baritone.launch.mixins.MixinCommandSuggestionHelper -> baritone.launch.mixins.MixinCommandSuggestionHelper:
    eol g -> g
    java.util.List o -> o
    com.mojang.brigadier.ParseResults r -> r
    java.util.concurrent.CompletableFuture s -> s
    eof$a t -> t
    boolean v -> v
    void <init>() -> <init>
    void preUpdateSuggestion(org.spongepowered.asm.mixin.injection.callback.CallbackInfo) -> preUpdateSuggestion
    com.mojang.brigadier.suggestion.Suggestion lambda$preUpdateSuggestion$0(com.mojang.brigadier.context.StringRange,java.lang.String) -> lambda$preUpdateSuggestion$0
baritone.launch.mixins.MixinEntity -> baritone.launch.mixins.MixinEntity:
    float aE -> aE
    float aF -> aF
    baritone.api.event.events.RotationMoveEvent motionUpdateRotationEvent -> motionUpdateRotationEvent
    void <init>() -> <init>
    void moveRelativeHead(org.spongepowered.asm.mixin.injection.callback.CallbackInfo) -> moveRelativeHead
    void moveRelativeReturn(org.spongepowered.asm.mixin.injection.callback.CallbackInfo) -> moveRelativeReturn
baritone.launch.mixins.MixinEntityRenderManager -> baritone.launch.mixins.MixinEntityRenderManager:
    void <init>() -> <init>
    double renderPosX() -> renderPosX
    double renderPosY() -> renderPosY
    double renderPosZ() -> renderPosZ
baritone.launch.mixins.MixinFireworkRocketEntity -> baritone.launch.mixins.MixinFireworkRocketEntity:
    acl c -> c
    bfx g -> g
    boolean q() -> q
    void <init>(cmi) -> <init>
    bfx getBoostedEntity() -> getBoostedEntity
baritone.launch.mixins.MixinItemStack -> baritone.launch.mixins.MixinItemStack:
    cfq u -> u
    int baritoneHash -> baritoneHash
    void <init>() -> <init>
    int j() -> j
    void recalculateHash() -> recalculateHash
    void onInit(org.spongepowered.asm.mixin.injection.callback.CallbackInfo) -> onInit
    void onItemDamageSet(org.spongepowered.asm.mixin.injection.callback.CallbackInfo) -> onItemDamageSet
    int getBaritoneHash() -> getBaritoneHash
baritone.launch.mixins.MixinLivingEntity -> baritone.launch.mixins.MixinLivingEntity:
    baritone.api.event.events.RotationMoveEvent jumpRotationEvent -> jumpRotationEvent
    baritone.api.event.events.RotationMoveEvent elytraRotationEvent -> elytraRotationEvent
    void <init>(bfl,cmi) -> <init>
    void preMoveRelative(org.spongepowered.asm.mixin.injection.callback.CallbackInfo) -> preMoveRelative
    float overrideYaw(bfx) -> overrideYaw
    void onPreElytraMove(ede,org.spongepowered.asm.mixin.injection.callback.CallbackInfo) -> onPreElytraMove
    void onPostElytraMove(ede,org.spongepowered.asm.mixin.injection.callback.CallbackInfo) -> onPostElytraMove
    java.util.Optional getBaritone() -> getBaritone
    void lambda$onPreElytraMove$1(baritone.api.IBaritone) -> lambda$onPreElytraMove$1
    void lambda$preMoveRelative$0(baritone.api.IBaritone) -> lambda$preMoveRelative$0
baritone.launch.mixins.MixinLootContext -> baritone.launch.mixins.MixinLootContext:
    void <init>() -> <init>
    net.minecraft.server.MinecraftServer getServer(aip) -> getServer
    dyv getLootTableManager(net.minecraft.server.MinecraftServer) -> getLootTableManager
    dyw getLootPredicateManager(net.minecraft.server.MinecraftServer) -> getLootPredicateManager
baritone.launch.mixins.MixinMinecraft -> baritone.launch.mixins.MixinMinecraft:
    fhk t -> t
    fdj s -> s
    java.util.function.BiFunction tickProvider -> tickProvider
    void <init>() -> <init>
    void postInit(org.spongepowered.asm.mixin.injection.callback.CallbackInfo) -> postInit
    void runTick(org.spongepowered.asm.mixin.injection.callback.CallbackInfo) -> runTick
    void postRunTick(org.spongepowered.asm.mixin.injection.callback.CallbackInfo) -> postRunTick
    void postUpdateEntities(org.spongepowered.asm.mixin.injection.callback.CallbackInfo) -> postUpdateEntities
    void preLoadWorld(fdj,org.spongepowered.asm.mixin.injection.callback.CallbackInfo) -> preLoadWorld
    void postLoadWorld(fdj,org.spongepowered.asm.mixin.injection.callback.CallbackInfo) -> postLoadWorld
    boolean passEvents(etd) -> passEvents
baritone.launch.mixins.MixinNetworkManager -> baritone.launch.mixins.MixinNetworkManager:
    io.netty.channel.Channel m -> m
    vc k -> k
    void <init>() -> <init>
    void preDispatchPacket(vb,sy,org.spongepowered.asm.mixin.injection.callback.CallbackInfo) -> preDispatchPacket
    void postDispatchPacket(vb,sy,org.spongepowered.asm.mixin.injection.callback.CallbackInfo) -> postDispatchPacket
    void preProcessPacket(io.netty.channel.ChannelHandlerContext,vb,org.spongepowered.asm.mixin.injection.callback.CallbackInfo) -> preProcessPacket
    void postProcessPacket(io.netty.channel.ChannelHandlerContext,vb,org.spongepowered.asm.mixin.injection.callback.CallbackInfo) -> postProcessPacket
baritone.launch.mixins.MixinPalettedContainer -> baritone.launch.mixins.MixinPalettedContainer:
    java.lang.invoke.MethodHandle DATA_GETTER -> DATA_GETTER
    void <init>() -> <init>
    ded getPalette() -> getPalette
    aoc getStorage() -> getStorage
    baritone.utils.accessor.IPalettedContainer$IData data() -> data
    java.lang.Throwable sneaky(java.lang.Throwable,java.lang.Class) -> sneaky
    void <clinit>() -> <clinit>
baritone.launch.mixins.MixinPalettedContainer$Data -> baritone.launch.mixins.MixinPalettedContainer$Data:
    void <init>() -> <init>
    ded getPalette() -> getPalette
    aoc getStorage() -> getStorage
baritone.launch.mixins.MixinPlayerController -> baritone.launch.mixins.MixinPlayerController:
    void <init>() -> <init>
    void setIsHittingBlock(boolean) -> setIsHittingBlock
    boolean isHittingBlock() -> isHittingBlock
    gt getCurrentBlock() -> getCurrentBlock
    void callSyncCurrentPlayItem() -> callSyncCurrentPlayItem
    void setDestroyDelay(int) -> setDestroyDelay
baritone.launch.mixins.MixinScreen -> baritone.launch.mixins.MixinScreen:
    void <init>() -> <init>
    void openLinkInvoker(java.net.URI) -> openLinkInvoker
    void handleCustomClickEvent(uf,org.spongepowered.asm.mixin.injection.callback.CallbackInfoReturnable) -> handleCustomClickEvent
baritone.launch.mixins.MixinWorldRenderer -> baritone.launch.mixins.MixinWorldRenderer:
    void <init>() -> <init>
    void onStartHand(ehe,float,long,boolean,elt,fhz,fif,org.joml.Matrix4f,org.spongepowered.asm.mixin.injection.callback.CallbackInfo) -> onStartHand
baritone.launch.tweaker.BaritoneTweaker -> baritone.launch.tweaker.BaritoneTweaker:
    void <init>() -> <init>
    void injectIntoClassLoader(net.minecraft.launchwrapper.LaunchClassLoader) -> injectIntoClassLoader
    boolean lambda$injectIntoClassLoader$0(java.lang.String) -> lambda$injectIntoClassLoader$0
baritone.pathing.calc.AStarPathFinder -> baritone.hd:
    baritone.utils.pathing.Favoring favoring -> a
    baritone.pathing.movement.CalculationContext calcContext -> a
    void <init>(baritone.api.utils.BetterBlockPos,int,int,int,baritone.api.pathing.goals.Goal,baritone.utils.pathing.Favoring,baritone.pathing.movement.CalculationContext) -> <init>
    java.util.Optional calculate0(long,long) -> a
baritone.pathing.calc.AbstractNodeCostSearch -> baritone.he:
    baritone.api.utils.BetterBlockPos realStart -> a
    int startX -> a
    int startY -> b
    int startZ -> c
    baritone.api.pathing.goals.Goal goal -> a
    baritone.pathing.movement.CalculationContext context -> a
    it.unimi.dsi.fastutil.longs.Long2ObjectOpenHashMap map -> a
    baritone.pathing.calc.PathNode startNode -> a
    baritone.pathing.calc.PathNode mostRecentConsidered -> b
    baritone.pathing.calc.PathNode[] bestSoFar -> a
    boolean isFinished -> b
    boolean cancelRequested -> a
    double[] COEFFICIENTS -> a
    void <init>(baritone.api.utils.BetterBlockPos,int,int,int,baritone.api.pathing.goals.Goal,baritone.pathing.movement.CalculationContext) -> <init>
    void cancel() -> a
    baritone.api.utils.PathCalculationResult calculate(long,long) -> a
    java.util.Optional calculate0(long,long) -> a
    double getDistFromStartSq(baritone.pathing.calc.PathNode) -> a
    baritone.pathing.calc.PathNode getNodeAtPosition(int,int,int,long) -> a
    java.util.Optional pathToMostRecentNodeConsidered() -> a
    java.util.Optional bestPathSoFar() -> b
    java.util.Optional bestSoFar(boolean,int) -> a
    baritone.api.pathing.goals.Goal getGoal() -> a
    baritone.api.utils.BetterBlockPos getStart() -> a
    int mapSize() -> a
    baritone.api.pathing.calc.IPath lambda$pathToMostRecentNodeConsidered$0(baritone.pathing.calc.PathNode) -> a
    void <clinit>() -> <clinit>
baritone.pathing.calc.Path -> baritone.hf:
    baritone.api.utils.BetterBlockPos start -> a
    baritone.api.utils.BetterBlockPos end -> b
    java.util.List path -> a
    java.util.List movements -> b
    java.util.List nodes -> c
    baritone.api.pathing.goals.Goal goal -> a
    int numNodes -> a
    baritone.pathing.movement.CalculationContext context -> a
    boolean verified -> a
    void <init>(baritone.api.utils.BetterBlockPos,baritone.pathing.calc.PathNode,baritone.pathing.calc.PathNode,int,baritone.api.pathing.goals.Goal,baritone.pathing.movement.CalculationContext) -> <init>
    baritone.api.pathing.goals.Goal getGoal() -> a
    boolean assembleMovements() -> a
    baritone.pathing.movement.Movement runBackwards(baritone.api.utils.BetterBlockPos,baritone.api.utils.BetterBlockPos,double) -> a
    baritone.api.pathing.calc.IPath postProcess() -> a
    java.util.List movements() -> a
    java.util.List positions() -> b
    int getNumNodesConsidered() -> b
    baritone.api.utils.BetterBlockPos getSrc() -> a
    baritone.api.utils.BetterBlockPos getDest() -> b
    void lambda$postProcess$0(baritone.pathing.movement.Movement) -> a
baritone.pathing.calc.PathNode -> baritone.hg:
    int x -> a
    int y -> b
    int z -> c
    double estimatedCostToGoal -> a
    double cost -> b
    double combinedCost -> c
    baritone.pathing.calc.PathNode previous -> a
    int heapPosition -> d
    void <init>(int,int,int,baritone.api.pathing.goals.Goal) -> <init>
    int hashCode() -> hashCode
    boolean equals(java.lang.Object) -> equals
baritone.pathing.calc.openset.BinaryHeapOpenSet -> baritone.hh:
    baritone.pathing.calc.PathNode[] array -> a
    int size -> a
    void <init>() -> <init>
    void <init>(byte) -> <init>
    void insert(baritone.pathing.calc.PathNode) -> a
    void update(baritone.pathing.calc.PathNode) -> b
baritone.pathing.movement.CalculationContext -> baritone.hi:
    cfv STACK_BUCKET_WATER -> a
    boolean safeForThreadedUse -> a
    baritone.api.IBaritone baritone -> a
    cmi world -> a
    baritone.cache.WorldData worldData -> a
    baritone.utils.BlockStateInterface bsi -> a
    baritone.utils.ToolSet toolSet -> a
    boolean hasWaterBucket -> b
    boolean hasThrowaway -> c
    boolean canSprint -> d
    double placeBlockCost -> a
    boolean allowBreak -> e
    java.util.List allowBreakAnyway -> a
    boolean allowParkour -> f
    boolean allowParkourPlace -> g
    boolean allowJumpAtBuildLimit -> h
    boolean allowParkourAscend -> i
    boolean assumeWalkOnWater -> j
    boolean allowFallIntoLava -> k
    int frostWalker -> a
    boolean allowDiagonalDescend -> l
    boolean allowDiagonalAscend -> m
    boolean allowDownward -> n
    int minFallHeight -> b
    int maxFallHeightNoWater -> c
    int maxFallHeightBucket -> d
    double waterWalkSpeed -> b
    double breakBlockAdditionalCost -> c
    double backtrackCostFavoringCoefficient -> d
    double jumpPenalty -> e
    double walkOnWaterOnePenalty -> f
    boolean allowWalkOnMagmaBlocks -> o
    baritone.utils.pathing.BetterWorldBorder worldBorder -> a
    baritone.pathing.precompute.PrecomputedData precomputedData -> a
    void <init>(baritone.api.IBaritone) -> <init>
    void <init>(baritone.api.IBaritone,boolean) -> <init>
    dbq get(int,int,int) -> a
    dbq get(gt) -> a
    cpi getBlock(int,int,int) -> a
    double costOfPlacingAt(int,int,int,dbq) -> a
    double breakCostMultiplierAt(int,int,int,dbq) -> b
    double placeBucketCost() -> a
    void <clinit>() -> <clinit>
baritone.pathing.movement.Movement -> baritone.hj:
    gz[] HORIZONTALS_BUT_ALSO_DOWN_____SO_EVERY_DIRECTION_EXCEPT_UP -> a
    baritone.api.IBaritone baritone -> a
    baritone.api.utils.IPlayerContext ctx -> a
    baritone.pathing.movement.MovementState currentState -> a
    baritone.api.utils.BetterBlockPos src -> a
    baritone.api.utils.BetterBlockPos dest -> b
    baritone.api.utils.BetterBlockPos[] positionsToBreak -> a
    baritone.api.utils.BetterBlockPos positionToPlace -> c
    java.lang.Double cost -> a
    java.util.List toBreakCached -> a
    java.util.List toPlaceCached -> b
    java.util.List toWalkIntoCached -> c
    java.util.Set validPositionsCached -> a
    java.lang.Boolean calculatedWhileLoaded -> a
    void <init>(baritone.api.IBaritone,baritone.api.utils.BetterBlockPos,baritone.api.utils.BetterBlockPos,baritone.api.utils.BetterBlockPos[],baritone.api.utils.BetterBlockPos) -> <init>
    void <init>(baritone.api.IBaritone,baritone.api.utils.BetterBlockPos,baritone.api.utils.BetterBlockPos,baritone.api.utils.BetterBlockPos[]) -> <init>
    double getCost() -> a
    double calculateCost(baritone.pathing.movement.CalculationContext) -> a
    java.util.Set calculateValidPositions() -> a
    java.util.Set getValidPositions() -> b
    boolean playerInValidPosition() -> b
    baritone.api.pathing.movement.MovementStatus update() -> a
    boolean prepared(baritone.pathing.movement.MovementState) -> a
    boolean safeToCancel() -> a
    boolean safeToCancel(baritone.pathing.movement.MovementState) -> b
    baritone.api.utils.BetterBlockPos getSrc() -> a
    baritone.api.utils.BetterBlockPos getDest() -> b
    void reset() -> a
    baritone.pathing.movement.MovementState updateState(baritone.pathing.movement.MovementState) -> a
    gt getDirection() -> a
    void checkLoadedChunk(baritone.pathing.movement.CalculationContext) -> a
    java.util.List toBreak(baritone.utils.BlockStateInterface) -> a
    java.util.List toPlace(baritone.utils.BlockStateInterface) -> b
    java.util.List toWalkInto(baritone.utils.BlockStateInterface) -> c
    gt[] toBreakAll() -> a
    void lambda$update$2(baritone.api.utils.input.Input,java.lang.Boolean) -> a
    void lambda$update$1(baritone.api.utils.Rotation) -> a
    void lambda$update$0(gt) -> a
    void <clinit>() -> <clinit>
baritone.pathing.movement.MovementHelper -> baritone.hk:
    boolean avoidBreaking(baritone.utils.BlockStateInterface,int,int,int,dbq) -> a
    boolean avoidAdjacentBreaking(baritone.utils.BlockStateInterface,int,int,int,boolean) -> a
    boolean canWalkThrough(baritone.api.utils.IPlayerContext,baritone.api.utils.BetterBlockPos) -> a
    boolean canWalkThrough(baritone.utils.BlockStateInterface,int,int,int) -> a
    boolean canWalkThrough(baritone.pathing.movement.CalculationContext,int,int,int,dbq) -> a
    boolean canWalkThrough(baritone.pathing.movement.CalculationContext,int,int,int) -> a
    boolean canWalkThrough(baritone.utils.BlockStateInterface,int,int,int,dbq) -> b
    baritone.pathing.precompute.Ternary canWalkThroughBlockState(dbq) -> a
    boolean canWalkThroughPosition(baritone.utils.BlockStateInterface,int,int,int,dbq) -> c
    baritone.pathing.precompute.Ternary fullyPassableBlockState(dbq) -> b
    boolean fullyPassable(baritone.pathing.movement.CalculationContext,int,int,int) -> b
    boolean fullyPassable(baritone.pathing.movement.CalculationContext,int,int,int,dbq) -> b
    boolean fullyPassable(baritone.api.utils.IPlayerContext,gt) -> a
    boolean fullyPassablePosition(baritone.utils.BlockStateInterface,int,int,int,dbq) -> d
    boolean isReplaceable$746798a3(int,int,dbq,baritone.utils.BlockStateInterface) -> a
    boolean isDoorPassable(baritone.api.utils.IPlayerContext,gt,gt) -> a
    boolean isGatePassable(baritone.api.utils.IPlayerContext,gt,gt) -> b
    boolean avoidWalkingInto(dbq) -> a
    boolean canWalkOn(baritone.utils.BlockStateInterface,int,int,int,dbq) -> e
    baritone.pathing.precompute.Ternary canWalkOnBlockState(dbq) -> c
    boolean canWalkOnPosition(baritone.utils.BlockStateInterface,int,int,int,dbq) -> f
    boolean canWalkOn(baritone.pathing.movement.CalculationContext,int,int,int,dbq) -> c
    boolean canWalkOn(baritone.pathing.movement.CalculationContext,int,int,int) -> c
    boolean canWalkOn(baritone.api.utils.IPlayerContext,gt) -> b
    boolean canWalkOn(baritone.api.utils.IPlayerContext,baritone.api.utils.BetterBlockPos) -> b
    boolean canWalkOn(baritone.utils.BlockStateInterface,int,int,int) -> b
    boolean canUseFrostWalker(baritone.pathing.movement.CalculationContext,dbq) -> a
    boolean canUseFrostWalker(baritone.api.utils.IPlayerContext,gt) -> c
    boolean mustBeSolidToWalkOn(baritone.pathing.movement.CalculationContext,int,int,int,dbq) -> d
    boolean canPlaceAgainst(baritone.utils.BlockStateInterface,int,int,int) -> c
    boolean canPlaceAgainst(baritone.api.utils.IPlayerContext,gt) -> d
    boolean canPlaceAgainst$1b0c4323(baritone.utils.BlockStateInterface,int,int,dbq) -> a
    double getMiningDurationTicks(baritone.pathing.movement.CalculationContext,int,int,int,boolean) -> a
    double getMiningDurationTicks(baritone.pathing.movement.CalculationContext,int,int,int,dbq,boolean) -> a
    boolean isBottomSlab(dbq) -> b
    void switchToBestToolFor(baritone.api.utils.IPlayerContext,dbq) -> a
    void switchToBestToolFor(baritone.api.utils.IPlayerContext,dbq,baritone.utils.ToolSet,boolean) -> a
    void moveTowards(baritone.api.utils.IPlayerContext,baritone.pathing.movement.MovementState,gt) -> a
    void moveTowardsWithSlightRotation(baritone.api.utils.IPlayerContext,baritone.pathing.movement.MovementState,gt) -> b
    boolean isWater(dbq) -> c
    boolean isWater(baritone.api.utils.IPlayerContext,gt) -> e
    boolean isLava(dbq) -> d
    boolean isLiquid(baritone.api.utils.IPlayerContext,gt) -> f
    boolean isLiquid(dbq) -> e
    boolean possiblyFlowing(dbq) -> f
    boolean isFlowing(int,int,int,dbq,baritone.utils.BlockStateInterface) -> a
    boolean isBlockNormalCube(dbq) -> g
    baritone.pathing.movement.MovementHelper$PlaceResult attemptToPlaceABlock(baritone.pathing.movement.MovementState,baritone.api.IBaritone,gt,boolean,boolean) -> a
    boolean isTransparent(cpi) -> a
    java.util.List steppingOnBlocks(baritone.api.utils.IPlayerContext) -> a
    void lambda$moveTowardsWithoutRotation$1(baritone.pathing.movement.MovementState,baritone.pathing.movement.MovementOption) -> a
    java.lang.Float lambda$moveTowardsWithoutRotation$0(float,baritone.pathing.movement.MovementOption) -> a
baritone.pathing.movement.MovementHelper$PlaceResult -> baritone.hk$a:
    baritone.pathing.movement.MovementHelper$PlaceResult READY_TO_PLACE -> a
    baritone.pathing.movement.MovementHelper$PlaceResult ATTEMPTING -> b
    baritone.pathing.movement.MovementHelper$PlaceResult NO_OPTION -> c
    baritone.pathing.movement.MovementHelper$PlaceResult[] $VALUES -> a
    baritone.pathing.movement.MovementHelper$PlaceResult[] values() -> values
    baritone.pathing.movement.MovementHelper$PlaceResult valueOf(java.lang.String) -> valueOf
    void <init>(java.lang.String,int) -> <init>
    void <clinit>() -> <clinit>
baritone.pathing.movement.MovementOption -> baritone.hl:
    baritone.api.utils.input.Input input1 -> a
    baritone.api.utils.input.Input input2 -> b
    float motionX -> a
    float motionZ -> b
    void <init>(baritone.api.utils.input.Input,float,float) -> <init>
    void <init>(baritone.api.utils.input.Input,baritone.api.utils.input.Input,float,float) -> <init>
    java.util.stream.Stream getOptions(float,float,boolean) -> a
    java.lang.String toString() -> toString
    int hashCode() -> hashCode
    boolean equals(java.lang.Object) -> equals
baritone.pathing.movement.MovementState -> baritone.hm:
    baritone.api.pathing.movement.MovementStatus status -> a
    baritone.pathing.movement.MovementState$MovementTarget target -> a
    java.util.Map inputState -> a
    void <init>() -> <init>
    baritone.pathing.movement.MovementState setTarget(baritone.pathing.movement.MovementState$MovementTarget) -> a
    baritone.pathing.movement.MovementState setInput(baritone.api.utils.input.Input,boolean) -> a
baritone.pathing.movement.MovementState$MovementTarget -> baritone.hm$a:
    baritone.api.utils.Rotation rotation -> a
    boolean forceRotations -> a
    void <init>() -> <init>
    void <init>(baritone.api.utils.Rotation,boolean) -> <init>
baritone.pathing.movement.Moves -> baritone.hn:
    baritone.pathing.movement.Moves DOWNWARD -> a
    baritone.pathing.movement.Moves PILLAR -> b
    baritone.pathing.movement.Moves TRAVERSE_NORTH -> c
    baritone.pathing.movement.Moves TRAVERSE_SOUTH -> d
    baritone.pathing.movement.Moves TRAVERSE_EAST -> e
    baritone.pathing.movement.Moves TRAVERSE_WEST -> f
    baritone.pathing.movement.Moves ASCEND_NORTH -> g
    baritone.pathing.movement.Moves ASCEND_SOUTH -> h
    baritone.pathing.movement.Moves ASCEND_EAST -> i
    baritone.pathing.movement.Moves ASCEND_WEST -> j
    baritone.pathing.movement.Moves DESCEND_EAST -> k
    baritone.pathing.movement.Moves DESCEND_WEST -> l
    baritone.pathing.movement.Moves DESCEND_NORTH -> m
    baritone.pathing.movement.Moves DESCEND_SOUTH -> n
    baritone.pathing.movement.Moves DIAGONAL_NORTHEAST -> o
    baritone.pathing.movement.Moves DIAGONAL_NORTHWEST -> p
    baritone.pathing.movement.Moves DIAGONAL_SOUTHEAST -> q
    baritone.pathing.movement.Moves DIAGONAL_SOUTHWEST -> r
    baritone.pathing.movement.Moves PARKOUR_NORTH -> s
    baritone.pathing.movement.Moves PARKOUR_SOUTH -> t
    baritone.pathing.movement.Moves PARKOUR_EAST -> u
    baritone.pathing.movement.Moves PARKOUR_WEST -> v
    boolean dynamicXZ -> a
    boolean dynamicY -> b
    int xOffset -> a
    int yOffset -> b
    int zOffset -> c
    baritone.pathing.movement.Moves[] $VALUES -> a
    baritone.pathing.movement.Moves[] values() -> values
    baritone.pathing.movement.Moves valueOf(java.lang.String) -> valueOf
    void <init>(java.lang.String,int,int,int,int,boolean,boolean) -> <init>
    void <init>(java.lang.String,int,int,int,int) -> <init>
    baritone.pathing.movement.Movement apply0(baritone.pathing.movement.CalculationContext,baritone.api.utils.BetterBlockPos) -> a
    void apply(baritone.pathing.movement.CalculationContext,int,int,int,baritone.utils.pathing.MutableMoveResult) -> a
    double cost(baritone.pathing.movement.CalculationContext,int,int,int) -> a
    void <clinit>() -> <clinit>
baritone.pathing.movement.Moves$1 -> baritone.ho:
    void <init>(java.lang.String) -> <init>
    baritone.pathing.movement.Movement apply0(baritone.pathing.movement.CalculationContext,baritone.api.utils.BetterBlockPos) -> a
    double cost(baritone.pathing.movement.CalculationContext,int,int,int) -> a
baritone.pathing.movement.Moves$10 -> baritone.hp:
    void <init>(java.lang.String) -> <init>
    baritone.pathing.movement.Movement apply0(baritone.pathing.movement.CalculationContext,baritone.api.utils.BetterBlockPos) -> a
    double cost(baritone.pathing.movement.CalculationContext,int,int,int) -> a
baritone.pathing.movement.Moves$11 -> baritone.hq:
    void <init>(java.lang.String) -> <init>
    baritone.pathing.movement.Movement apply0(baritone.pathing.movement.CalculationContext,baritone.api.utils.BetterBlockPos) -> a
    void apply(baritone.pathing.movement.CalculationContext,int,int,int,baritone.utils.pathing.MutableMoveResult) -> a
baritone.pathing.movement.Moves$12 -> baritone.hr:
    void <init>(java.lang.String) -> <init>
    baritone.pathing.movement.Movement apply0(baritone.pathing.movement.CalculationContext,baritone.api.utils.BetterBlockPos) -> a
    void apply(baritone.pathing.movement.CalculationContext,int,int,int,baritone.utils.pathing.MutableMoveResult) -> a
baritone.pathing.movement.Moves$13 -> baritone.hs:
    void <init>(java.lang.String) -> <init>
    baritone.pathing.movement.Movement apply0(baritone.pathing.movement.CalculationContext,baritone.api.utils.BetterBlockPos) -> a
    void apply(baritone.pathing.movement.CalculationContext,int,int,int,baritone.utils.pathing.MutableMoveResult) -> a
baritone.pathing.movement.Moves$14 -> baritone.ht:
    void <init>(java.lang.String) -> <init>
    baritone.pathing.movement.Movement apply0(baritone.pathing.movement.CalculationContext,baritone.api.utils.BetterBlockPos) -> a
    void apply(baritone.pathing.movement.CalculationContext,int,int,int,baritone.utils.pathing.MutableMoveResult) -> a
baritone.pathing.movement.Moves$15 -> baritone.hu:
    void <init>(java.lang.String) -> <init>
    baritone.pathing.movement.Movement apply0(baritone.pathing.movement.CalculationContext,baritone.api.utils.BetterBlockPos) -> a
    void apply(baritone.pathing.movement.CalculationContext,int,int,int,baritone.utils.pathing.MutableMoveResult) -> a
baritone.pathing.movement.Moves$16 -> baritone.hv:
    void <init>(java.lang.String) -> <init>
    baritone.pathing.movement.Movement apply0(baritone.pathing.movement.CalculationContext,baritone.api.utils.BetterBlockPos) -> a
    void apply(baritone.pathing.movement.CalculationContext,int,int,int,baritone.utils.pathing.MutableMoveResult) -> a
baritone.pathing.movement.Moves$17 -> baritone.hw:
    void <init>(java.lang.String) -> <init>
    baritone.pathing.movement.Movement apply0(baritone.pathing.movement.CalculationContext,baritone.api.utils.BetterBlockPos) -> a
    void apply(baritone.pathing.movement.CalculationContext,int,int,int,baritone.utils.pathing.MutableMoveResult) -> a
baritone.pathing.movement.Moves$18 -> baritone.hx:
    void <init>(java.lang.String) -> <init>
    baritone.pathing.movement.Movement apply0(baritone.pathing.movement.CalculationContext,baritone.api.utils.BetterBlockPos) -> a
    void apply(baritone.pathing.movement.CalculationContext,int,int,int,baritone.utils.pathing.MutableMoveResult) -> a
baritone.pathing.movement.Moves$19 -> baritone.hy:
    void <init>(java.lang.String) -> <init>
    baritone.pathing.movement.Movement apply0(baritone.pathing.movement.CalculationContext,baritone.api.utils.BetterBlockPos) -> a
    void apply(baritone.pathing.movement.CalculationContext,int,int,int,baritone.utils.pathing.MutableMoveResult) -> a
baritone.pathing.movement.Moves$2 -> baritone.hz:
    void <init>(java.lang.String) -> <init>
    baritone.pathing.movement.Movement apply0(baritone.pathing.movement.CalculationContext,baritone.api.utils.BetterBlockPos) -> a
    double cost(baritone.pathing.movement.CalculationContext,int,int,int) -> a
baritone.pathing.movement.Moves$20 -> baritone.ia:
    void <init>(java.lang.String) -> <init>
    baritone.pathing.movement.Movement apply0(baritone.pathing.movement.CalculationContext,baritone.api.utils.BetterBlockPos) -> a
    void apply(baritone.pathing.movement.CalculationContext,int,int,int,baritone.utils.pathing.MutableMoveResult) -> a
baritone.pathing.movement.Moves$21 -> baritone.ib:
    void <init>(java.lang.String) -> <init>
    baritone.pathing.movement.Movement apply0(baritone.pathing.movement.CalculationContext,baritone.api.utils.BetterBlockPos) -> a
    void apply(baritone.pathing.movement.CalculationContext,int,int,int,baritone.utils.pathing.MutableMoveResult) -> a
baritone.pathing.movement.Moves$22 -> baritone.ic:
    void <init>(java.lang.String) -> <init>
    baritone.pathing.movement.Movement apply0(baritone.pathing.movement.CalculationContext,baritone.api.utils.BetterBlockPos) -> a
    void apply(baritone.pathing.movement.CalculationContext,int,int,int,baritone.utils.pathing.MutableMoveResult) -> a
baritone.pathing.movement.Moves$3 -> baritone.id:
    void <init>(java.lang.String) -> <init>
    baritone.pathing.movement.Movement apply0(baritone.pathing.movement.CalculationContext,baritone.api.utils.BetterBlockPos) -> a
    double cost(baritone.pathing.movement.CalculationContext,int,int,int) -> a
baritone.pathing.movement.Moves$4 -> baritone.ie:
    void <init>(java.lang.String) -> <init>
    baritone.pathing.movement.Movement apply0(baritone.pathing.movement.CalculationContext,baritone.api.utils.BetterBlockPos) -> a
    double cost(baritone.pathing.movement.CalculationContext,int,int,int) -> a
baritone.pathing.movement.Moves$5 -> baritone.if:
    void <init>(java.lang.String) -> <init>
    baritone.pathing.movement.Movement apply0(baritone.pathing.movement.CalculationContext,baritone.api.utils.BetterBlockPos) -> a
    double cost(baritone.pathing.movement.CalculationContext,int,int,int) -> a
baritone.pathing.movement.Moves$6 -> baritone.ig:
    void <init>(java.lang.String) -> <init>
    baritone.pathing.movement.Movement apply0(baritone.pathing.movement.CalculationContext,baritone.api.utils.BetterBlockPos) -> a
    double cost(baritone.pathing.movement.CalculationContext,int,int,int) -> a
baritone.pathing.movement.Moves$7 -> baritone.ih:
    void <init>(java.lang.String) -> <init>
    baritone.pathing.movement.Movement apply0(baritone.pathing.movement.CalculationContext,baritone.api.utils.BetterBlockPos) -> a
    double cost(baritone.pathing.movement.CalculationContext,int,int,int) -> a
baritone.pathing.movement.Moves$8 -> baritone.ii:
    void <init>(java.lang.String) -> <init>
    baritone.pathing.movement.Movement apply0(baritone.pathing.movement.CalculationContext,baritone.api.utils.BetterBlockPos) -> a
    double cost(baritone.pathing.movement.CalculationContext,int,int,int) -> a
baritone.pathing.movement.Moves$9 -> baritone.ij:
    void <init>(java.lang.String) -> <init>
    baritone.pathing.movement.Movement apply0(baritone.pathing.movement.CalculationContext,baritone.api.utils.BetterBlockPos) -> a
    double cost(baritone.pathing.movement.CalculationContext,int,int,int) -> a
baritone.pathing.movement.movements.MovementAscend -> baritone.ik:
    int ticksWithoutPlacement -> a
    void <init>(baritone.api.IBaritone,baritone.api.utils.BetterBlockPos,baritone.api.utils.BetterBlockPos) -> <init>
    void reset() -> a
    double calculateCost(baritone.pathing.movement.CalculationContext) -> a
    java.util.Set calculateValidPositions() -> a
    double cost(baritone.pathing.movement.CalculationContext,int,int,int,int,int) -> a
    baritone.pathing.movement.MovementState updateState(baritone.pathing.movement.MovementState) -> a
    boolean safeToCancel(baritone.pathing.movement.MovementState) -> b
baritone.pathing.movement.movements.MovementDescend -> baritone.il:
    int numTicks -> a
    boolean forceSafeMode -> a
    void <init>(baritone.api.IBaritone,baritone.api.utils.BetterBlockPos,baritone.api.utils.BetterBlockPos) -> <init>
    void reset() -> a
    double calculateCost(baritone.pathing.movement.CalculationContext) -> a
    java.util.Set calculateValidPositions() -> a
    void cost(baritone.pathing.movement.CalculationContext,int,int,int,int,int,baritone.utils.pathing.MutableMoveResult) -> a
    boolean dynamicFallCost$6fca93b2(baritone.pathing.movement.CalculationContext,int,int,int,double,dbq,baritone.utils.pathing.MutableMoveResult) -> a
    baritone.pathing.movement.MovementState updateState(baritone.pathing.movement.MovementState) -> a
    boolean safeMode() -> c
    boolean skipToAscend() -> d
baritone.pathing.movement.movements.MovementDiagonal -> baritone.im:
    double SQRT_2 -> d
    void <init>(baritone.api.IBaritone,baritone.api.utils.BetterBlockPos,gz,gz,int) -> <init>
    void <init>(baritone.api.IBaritone,baritone.api.utils.BetterBlockPos,baritone.api.utils.BetterBlockPos,baritone.api.utils.BetterBlockPos,gz,int) -> <init>
    void <init>(baritone.api.IBaritone,baritone.api.utils.BetterBlockPos,baritone.api.utils.BetterBlockPos,baritone.api.utils.BetterBlockPos,baritone.api.utils.BetterBlockPos) -> <init>
    boolean safeToCancel(baritone.pathing.movement.MovementState) -> b
    double calculateCost(baritone.pathing.movement.CalculationContext) -> a
    java.util.Set calculateValidPositions() -> a
    void cost(baritone.pathing.movement.CalculationContext,int,int,int,int,int,baritone.utils.pathing.MutableMoveResult) -> a
    baritone.pathing.movement.MovementState updateState(baritone.pathing.movement.MovementState) -> a
    boolean prepared(baritone.pathing.movement.MovementState) -> a
    java.util.List toBreak(baritone.utils.BlockStateInterface) -> a
    java.util.List toWalkInto(baritone.utils.BlockStateInterface) -> c
    boolean lambda$updateState$0(baritone.api.utils.BetterBlockPos) -> a
    void <clinit>() -> <clinit>
baritone.pathing.movement.movements.MovementDownward -> baritone.in:
    int numTicks -> a
    void <init>(baritone.api.IBaritone,baritone.api.utils.BetterBlockPos,baritone.api.utils.BetterBlockPos) -> <init>
    void reset() -> a
    double calculateCost(baritone.pathing.movement.CalculationContext) -> a
    java.util.Set calculateValidPositions() -> a
    double cost(baritone.pathing.movement.CalculationContext,int,int,int) -> a
    baritone.pathing.movement.MovementState updateState(baritone.pathing.movement.MovementState) -> a
baritone.pathing.movement.movements.MovementFall -> baritone.io:
    cfv STACK_BUCKET_WATER -> a
    cfv STACK_BUCKET_EMPTY -> b
    void <init>(baritone.api.IBaritone,baritone.api.utils.BetterBlockPos,baritone.api.utils.BetterBlockPos) -> <init>
    double calculateCost(baritone.pathing.movement.CalculationContext) -> a
    java.util.Set calculateValidPositions() -> a
    baritone.pathing.movement.MovementState updateState(baritone.pathing.movement.MovementState) -> a
    boolean safeToCancel(baritone.pathing.movement.MovementState) -> b
    baritone.api.utils.BetterBlockPos[] buildPositionsToBreak(baritone.api.utils.BetterBlockPos,baritone.api.utils.BetterBlockPos) -> a
    boolean prepared(baritone.pathing.movement.MovementState) -> a
    boolean lambda$updateState$0(baritone.api.utils.BetterBlockPos) -> a
    void <clinit>() -> <clinit>
baritone.pathing.movement.movements.MovementParkour -> baritone.ip:
    baritone.api.utils.BetterBlockPos[] EMPTY -> b
    gz direction -> a
    int dist -> a
    boolean ascend -> a
    void <init>(baritone.api.IBaritone,baritone.api.utils.BetterBlockPos,int,gz,boolean) -> <init>
    baritone.pathing.movement.movements.MovementParkour cost(baritone.pathing.movement.CalculationContext,baritone.api.utils.BetterBlockPos,gz) -> a
    void cost(baritone.pathing.movement.CalculationContext,int,int,int,gz,baritone.utils.pathing.MutableMoveResult) -> a
    boolean checkOvershootSafety(baritone.utils.BlockStateInterface,int,int,int) -> d
    double costFromJumpDistance(int) -> a
    double calculateCost(baritone.pathing.movement.CalculationContext) -> a
    java.util.Set calculateValidPositions() -> a
    boolean safeToCancel(baritone.pathing.movement.MovementState) -> b
    baritone.pathing.movement.MovementState updateState(baritone.pathing.movement.MovementState) -> a
    void <clinit>() -> <clinit>
baritone.pathing.movement.movements.MovementPillar -> baritone.iq:
    void <init>(baritone.api.IBaritone,baritone.api.utils.BetterBlockPos,baritone.api.utils.BetterBlockPos) -> <init>
    double calculateCost(baritone.pathing.movement.CalculationContext) -> a
    java.util.Set calculateValidPositions() -> a
    double cost(baritone.pathing.movement.CalculationContext,int,int,int) -> a
    boolean hasAgainst(baritone.pathing.movement.CalculationContext,int,int,int) -> d
    gt getAgainst(baritone.pathing.movement.CalculationContext,baritone.api.utils.BetterBlockPos) -> a
    baritone.pathing.movement.MovementState updateState(baritone.pathing.movement.MovementState) -> a
    boolean prepared(baritone.pathing.movement.MovementState) -> a
    baritone.pathing.movement.MovementState$MovementTarget lambda$updateState$0(baritone.api.utils.Rotation) -> a
baritone.pathing.movement.movements.MovementTraverse -> baritone.ir:
    boolean wasTheBridgeBlockAlwaysThere -> a
    void <init>(baritone.api.IBaritone,baritone.api.utils.BetterBlockPos,baritone.api.utils.BetterBlockPos) -> <init>
    void reset() -> a
    double calculateCost(baritone.pathing.movement.CalculationContext) -> a
    java.util.Set calculateValidPositions() -> a
    double cost(baritone.pathing.movement.CalculationContext,int,int,int,int,int) -> a
    baritone.pathing.movement.MovementState updateState(baritone.pathing.movement.MovementState) -> a
    boolean safeToCancel(baritone.pathing.movement.MovementState) -> b
    boolean prepared(baritone.pathing.movement.MovementState) -> a
    boolean lambda$updateState$0(baritone.api.utils.BetterBlockPos) -> a
baritone.pathing.movement.movements.MovementTraverse$1 -> baritone.is:
    int[] $SwitchMap$baritone$pathing$movement$MovementHelper$PlaceResult -> a
    void <clinit>() -> <clinit>
baritone.pathing.path.CutoffPath -> baritone.it:
    java.util.List path -> b
    java.util.List movements -> a
    int numNodes -> a
    baritone.api.pathing.goals.Goal goal -> a
    void <init>(baritone.api.pathing.calc.IPath,int,int) -> <init>
    void <init>(baritone.api.pathing.calc.IPath,int) -> <init>
    baritone.api.pathing.goals.Goal getGoal() -> a
    java.util.List movements() -> a
    java.util.List positions() -> b
    int getNumNodesConsidered() -> b
baritone.pathing.path.PathExecutor -> baritone.iu:
    baritone.api.pathing.calc.IPath path -> a
    int pathPosition -> a
    int ticksAway -> b
    int ticksOnCurrent -> c
    java.lang.Double currentMovementOriginalCostEstimate -> a
    java.lang.Integer costEstimateIndex -> a
    boolean failed -> a
    boolean recalcBP -> c
    java.util.HashSet toBreak -> a
    java.util.HashSet toPlace -> b
    java.util.HashSet toWalkInto -> c
    baritone.behavior.PathingBehavior behavior -> a
    baritone.api.utils.IPlayerContext ctx -> a
    boolean sprintNextTick -> b
    void <init>(baritone.behavior.PathingBehavior,baritone.api.pathing.calc.IPath) -> <init>
    boolean onTick() -> a
    boolean possiblyOffPath(aqh,double) -> a
    aqh overrideFall(baritone.pathing.movement.movements.MovementFall) -> a
    boolean sprintableAscend(baritone.api.utils.IPlayerContext,baritone.pathing.movement.movements.MovementTraverse,baritone.pathing.movement.movements.MovementAscend,baritone.api.pathing.movement.IMovement) -> a
    boolean canSprintFromDescendInto(baritone.api.utils.IPlayerContext,baritone.api.pathing.movement.IMovement,baritone.api.pathing.movement.IMovement) -> a
    void onChangeInPathPosition() -> b
    void clearKeys() -> a
    void cancel() -> c
    int getPosition() -> a
    baritone.pathing.path.PathExecutor trySplice(baritone.pathing.path.PathExecutor) -> a
    baritone.pathing.path.PathExecutor cutIfTooLong() -> a
    baritone.api.pathing.calc.IPath getPath() -> a
    boolean finished() -> b
    baritone.pathing.path.PathExecutor lambda$trySplice$0(baritone.pathing.path.PathExecutor,baritone.pathing.path.SplicedPath) -> a
baritone.pathing.path.SplicedPath -> baritone.iv:
    java.util.List path -> a
    java.util.List movements -> b
    int numNodes -> a
    baritone.api.pathing.goals.Goal goal -> a
    void <init>(java.util.List,java.util.List,int,baritone.api.pathing.goals.Goal) -> <init>
    baritone.api.pathing.goals.Goal getGoal() -> a
    java.util.List movements() -> a
    java.util.List positions() -> b
    int getNumNodesConsidered() -> b
    int length() -> a
baritone.pathing.precompute.PrecomputedData -> baritone.iw:
    byte[] data -> a
    void <init>() -> <init>
    int fillData(int,dbq) -> a
    boolean canWalkThrough(baritone.utils.BlockStateInterface,int,int,int,dbq) -> a
    boolean fullyPassable(baritone.utils.BlockStateInterface,int,int,int,dbq) -> b
baritone.pathing.precompute.PrecomputedData$1 -> baritone.ix:
    int[] $SwitchMap$baritone$pathing$precompute$Ternary -> a
    void <clinit>() -> <clinit>
baritone.pathing.precompute.Ternary -> baritone.iy:
    baritone.pathing.precompute.Ternary YES -> a
    baritone.pathing.precompute.Ternary MAYBE -> b
    baritone.pathing.precompute.Ternary NO -> c
    baritone.pathing.precompute.Ternary[] $VALUES -> a
    baritone.pathing.precompute.Ternary[] values() -> values
    baritone.pathing.precompute.Ternary valueOf(java.lang.String) -> valueOf
    void <init>(java.lang.String,int) -> <init>
    void <clinit>() -> <clinit>
baritone.process.BackfillProcess -> baritone.iz:
    java.util.HashMap blocksToReplace -> a
    void <init>(baritone.Baritone) -> <init>
    boolean isActive() -> a
    baritone.api.process.PathingCommand onTick(boolean,boolean) -> a
    java.util.List toFillIn() -> a
    void onLostControl() -> a
    java.lang.String displayName0() -> b
    boolean isTemporary() -> b
    double priority() -> a
    boolean lambda$toFillIn$2(gt) -> a
    boolean lambda$toFillIn$1(gt) -> b
    boolean lambda$toFillIn$0(gt) -> c
baritone.process.BackfillProcess$1 -> baritone.ja:
    int[] $SwitchMap$baritone$pathing$movement$MovementHelper$PlaceResult -> a
    void <clinit>() -> <clinit>
baritone.process.BuilderProcess -> baritone.jb:
    java.util.Set ORIENTATION_PROPS -> a
    java.util.HashSet incorrectPositions -> a
    it.unimi.dsi.fastutil.longs.LongOpenHashSet observedCompleted -> a
    java.lang.String name -> a
    baritone.api.schematic.ISchematic realSchematic -> b
    baritone.api.schematic.ISchematic schematic -> a
    hy origin -> a
    int ticks -> a
    boolean paused -> a
    int layer -> b
    int numRepeats -> c
    java.util.List approxPlaceable -> a
    int stopAtHeight -> d
    void <init>(baritone.Baritone) -> <init>
    void build(java.lang.String,baritone.api.schematic.ISchematic,hy) -> a
    void resume() -> b
    boolean build(java.lang.String,java.io.File,hy) -> a
    baritone.api.schematic.ISchematic applyMapArtAndSelection(hy,baritone.api.schematic.IStaticSchematic) -> a
    void buildOpenLitematic(int) -> a
    void clearArea(gt,gt) -> a
    boolean isActive() -> a
    java.util.Optional toBreakNearPlayer(baritone.process.BuilderProcess$BuilderCalculationContext) -> a
    java.util.Optional searchForPlacables(baritone.process.BuilderProcess$BuilderCalculationContext,java.util.List) -> a
    boolean placementPlausible(gt,dbq) -> a
    java.util.OptionalInt hasAnyItemThatWouldPlace(dbq,edc,baritone.api.utils.Rotation) -> a
    baritone.api.process.PathingCommand onTick(boolean,boolean) -> a
    void recalcNearby(baritone.process.BuilderProcess$BuilderCalculationContext) -> a
    void fullRecalc(baritone.process.BuilderProcess$BuilderCalculationContext) -> b
    baritone.api.pathing.goals.Goal assemble(baritone.process.BuilderProcess$BuilderCalculationContext,java.util.List,boolean) -> a
    void onLostControl() -> a
    java.lang.String displayName0() -> b
    java.util.List approxPlaceable(int) -> a
    boolean sameBlockstate(dbq,dbq) -> a
    boolean valid(dbq,dbq,boolean) -> a
    java.lang.String lambda$assemble$8(baritone.api.utils.BetterBlockPos) -> a
    java.lang.String lambda$assemble$7(java.util.Map$Entry) -> a
    void lambda$assemble$6(java.util.List,baritone.api.utils.BetterBlockPos) -> a
    void lambda$assemble$5(java.util.List,java.util.List,baritone.process.BuilderProcess$BuilderCalculationContext,baritone.api.utils.BetterBlockPos) -> a
    void lambda$assemble$4(java.util.List,baritone.process.BuilderProcess$BuilderCalculationContext,baritone.api.utils.BetterBlockPos) -> a
    void lambda$assemble$3(baritone.process.BuilderProcess$BuilderCalculationContext,java.util.List,java.util.List,java.util.List,java.util.Map,java.util.List,java.util.List,java.util.List,baritone.api.utils.BetterBlockPos) -> a
    boolean lambda$trim$2(baritone.api.utils.BetterBlockPos) -> a
    int lambda$build$1(baritone.api.selection.ISelection) -> a
    int lambda$build$0(baritone.api.selection.ISelection) -> b
    baritone.Baritone access$000(baritone.process.BuilderProcess) -> a
    void <clinit>() -> <clinit>
baritone.process.BuilderProcess$1 -> baritone.jc:
    void <init>(baritone.api.schematic.ISchematic) -> <init>
    boolean partOfMask(int,int,int,dbq) -> b
baritone.process.BuilderProcess$2 -> baritone.jd:
    void <init>(cmi,bym,bdx,cfv,eda) -> <init>
baritone.process.BuilderProcess$3 -> baritone.je:
    baritone.api.schematic.ISchematic val$realSchematic -> a
    int val$minYInclusive -> a
    int val$maxYInclusive -> b
    baritone.process.BuilderProcess this$0 -> a
    void <init>(baritone.process.BuilderProcess,baritone.api.schematic.ISchematic,int,int) -> <init>
    dbq desiredState(int,int,int,dbq,java.util.List) -> a
    boolean inSchematic(int,int,int,dbq) -> a
    void reset() -> a
    int widthX() -> a
    int heightY() -> b
    int lengthZ() -> c
baritone.process.BuilderProcess$4 -> baritone.jf:
    void <init>(gt) -> <init>
    boolean isInGoal(int,int,int) -> a
baritone.process.BuilderProcess$5 -> baritone.jg:
    void <init>(cmi,bym,bdx,cfv,eda) -> <init>
baritone.process.BuilderProcess$6 -> baritone.jh:
    int[] $SwitchMap$net$minecraft$core$Direction -> a
    void <clinit>() -> <clinit>
baritone.process.BuilderProcess$BuilderCalculationContext -> baritone.jb$a:
    java.util.List placeable -> b
    baritone.api.schematic.ISchematic schematic -> a
    int originX -> e
    int originY -> f
    int originZ -> g
    baritone.process.BuilderProcess this$0 -> a
    void <init>(baritone.process.BuilderProcess) -> <init>
    dbq getSchematic(int,int,int,dbq) -> a
    double costOfPlacingAt(int,int,int,dbq) -> a
    double breakCostMultiplierAt(int,int,int,dbq) -> b
baritone.process.BuilderProcess$GoalAdjacent -> baritone.jb$b:
    boolean allowSameLevel -> a
    gt no -> a
    void <init>(gt,gt,boolean) -> <init>
    boolean isInGoal(int,int,int) -> a
    double heuristic(int,int,int) -> a
    boolean equals(java.lang.Object) -> equals
    int hashCode() -> hashCode
    java.lang.String toString() -> toString
baritone.process.BuilderProcess$GoalBreak -> baritone.jb$c:
    void <init>(gt) -> <init>
    boolean isInGoal(int,int,int) -> a
    java.lang.String toString() -> toString
    int hashCode() -> hashCode
baritone.process.BuilderProcess$GoalPlace -> baritone.jb$d:
    void <init>(gt) -> <init>
    double heuristic(int,int,int) -> a
    int hashCode() -> hashCode
    java.lang.String toString() -> toString
baritone.process.BuilderProcess$JankyGoalComposite -> baritone.jb$e:
    baritone.api.pathing.goals.Goal primary -> a
    baritone.api.pathing.goals.Goal fallback -> b
    void <init>(baritone.api.pathing.goals.Goal,baritone.api.pathing.goals.Goal) -> <init>
    boolean isInGoal(int,int,int) -> a
    double heuristic(int,int,int) -> a
    boolean equals(java.lang.Object) -> equals
    int hashCode() -> hashCode
    java.lang.String toString() -> toString
baritone.process.BuilderProcess$Placement -> baritone.jb$f:
    int hotbarSelection -> a
    gt placeAgainst -> a
    gz side -> a
    baritone.api.utils.Rotation rot -> a
    void <init>(int,gt,gz,baritone.api.utils.Rotation) -> <init>
baritone.process.CustomGoalProcess -> baritone.ji:
    baritone.api.pathing.goals.Goal goal -> a
    baritone.api.pathing.goals.Goal mostRecentGoal -> b
    baritone.process.CustomGoalProcess$State state -> a
    void <init>(baritone.Baritone) -> <init>
    void setGoal(baritone.api.pathing.goals.Goal) -> a
    void path() -> b
    baritone.api.pathing.goals.Goal getGoal() -> a
    baritone.api.pathing.goals.Goal mostRecentGoal() -> b
    boolean isActive() -> a
    baritone.api.process.PathingCommand onTick(boolean,boolean) -> a
    void onLostControl() -> a
    java.lang.String displayName0() -> b
baritone.process.CustomGoalProcess$1 -> baritone.jj:
    int[] $SwitchMap$baritone$process$CustomGoalProcess$State -> a
    void <clinit>() -> <clinit>
baritone.process.CustomGoalProcess$State -> baritone.ji$a:
    baritone.process.CustomGoalProcess$State NONE -> a
    baritone.process.CustomGoalProcess$State GOAL_SET -> b
    baritone.process.CustomGoalProcess$State PATH_REQUESTED -> c
    baritone.process.CustomGoalProcess$State EXECUTING -> d
    baritone.process.CustomGoalProcess$State[] $VALUES -> a
    baritone.process.CustomGoalProcess$State[] values() -> values
    baritone.process.CustomGoalProcess$State valueOf(java.lang.String) -> valueOf
    void <init>(java.lang.String,int) -> <init>
    void <clinit>() -> <clinit>
baritone.process.ElytraProcess -> baritone.jk:
    baritone.process.ElytraProcess$State state -> a
    boolean goingToLandingSpot -> a
    baritone.api.utils.BetterBlockPos landingSpot -> a
    boolean reachedGoal -> b
    baritone.api.pathing.goals.Goal goal -> a
    baritone.process.elytra.ElytraBehavior behavior -> a
    boolean predictingTerrain -> c
    java.util.Set badLandingSpots -> a
    void onLostControl() -> a
    void <init>(baritone.Baritone) -> <init>
    baritone.api.process.IElytraProcess create(baritone.Baritone) -> a
    boolean isActive() -> a
    void resetState() -> c
    baritone.api.process.PathingCommand onTick(boolean,boolean) -> a
    void landingSpotIsBad(baritone.api.utils.BetterBlockPos) -> a
    void destroyBehaviorAsync() -> d
    double priority() -> a
    java.lang.String displayName0() -> b
    void repackChunks() -> b
    void pathTo0(gt,boolean) -> a
    void pathTo(baritone.api.pathing.goals.Goal) -> a
    boolean shouldLandForSafety() -> e
    boolean isLoaded() -> c
    boolean isSafeToCancel() -> d
    void onRenderPass$493a6673(baritone.cache.ChunkPacker) -> a
    void onWorldEvent(baritone.api.event.events.WorldEvent) -> a
    void onChunkEvent(baritone.api.event.events.ChunkEvent) -> a
    void onBlockChange$4a8de162(baritone.api.utils.NotificationHelper) -> a
    void onReceivePacket$1f25927f(baritone.api.utils.RayTraceUtils) -> b
    void onPostTick(baritone.api.event.events.TickEvent) -> b
    boolean isSafeBlock(cpi) -> a
    boolean isSafeBlock(gt) -> a
    boolean isColumnAir$5a35ae30(gt) -> b
    boolean hasAirBubble(gt) -> c
    baritone.api.utils.BetterBlockPos checkLandingSpot(gt,it.unimi.dsi.fastutil.longs.LongOpenHashSet) -> a
    int lambda$findSafeLandingSpot$3(baritone.api.utils.BetterBlockPos) -> a
    int lambda$findSafeLandingSpot$2(baritone.api.utils.BetterBlockPos,baritone.api.utils.BetterBlockPos) -> a
    void lambda$onTick$1(java.lang.Void,java.lang.Throwable) -> a
    boolean lambda$onTick$0(baritone.api.pathing.movement.IMovement) -> a
baritone.process.ElytraProcess$State -> baritone.jk$a:
    baritone.process.ElytraProcess$State LOCATE_JUMP -> a
    baritone.process.ElytraProcess$State PAUSE -> b
    baritone.process.ElytraProcess$State GET_TO_JUMP -> c
    baritone.process.ElytraProcess$State START_FLYING -> d
    baritone.process.ElytraProcess$State FLYING -> e
    baritone.process.ElytraProcess$State LANDING -> f
    java.lang.String description -> a
    baritone.process.ElytraProcess$State[] $VALUES -> a
    baritone.process.ElytraProcess$State[] values() -> values
    baritone.process.ElytraProcess$State valueOf(java.lang.String) -> valueOf
    void <init>(java.lang.String,int,java.lang.String) -> <init>
    void <clinit>() -> <clinit>
baritone.process.ElytraProcess$WalkOffCalculationContext -> baritone.jk$b:
    void <init>(baritone.api.IBaritone) -> <init>
    double costOfPlacingAt(int,int,int,dbq) -> a
    double breakCostMultiplierAt(int,int,int,dbq) -> b
    double placeBucketCost() -> a
baritone.process.ExploreProcess -> baritone.jl:
    gt explorationOrigin -> a
    baritone.process.ExploreProcess$IChunkFilter filter -> a
    int distanceCompleted -> a
    void <init>(baritone.Baritone) -> <init>
    boolean isActive() -> a
    void explore(int,int) -> a
    void applyJsonFilter(java.nio.file.Path,boolean) -> a
    baritone.process.ExploreProcess$IChunkFilter calcFilter() -> a
    baritone.api.process.PathingCommand onTick(boolean,boolean) -> a
    baritone.api.pathing.goals.Goal[] closestUncachedChunks(gt,baritone.process.ExploreProcess$IChunkFilter) -> a
    void onLostControl() -> a
    java.lang.String displayName0() -> b
    baritone.api.pathing.goals.Goal[] lambda$closestUncachedChunks$1(int) -> a
    baritone.api.pathing.goals.Goal lambda$closestUncachedChunks$0(gt) -> a
    baritone.Baritone access$000(baritone.process.ExploreProcess) -> a
baritone.process.ExploreProcess$1 -> baritone.jm:
    void <init>(int,int) -> <init>
    double heuristic(int,int,int) -> a
baritone.process.ExploreProcess$2 -> baritone.jn:
    int[] $SwitchMap$baritone$process$ExploreProcess$Status -> a
    void <clinit>() -> <clinit>
baritone.process.ExploreProcess$BaritoneChunkCache -> baritone.jl$a:
    baritone.api.cache.ICachedWorld cache -> a
    baritone.process.ExploreProcess this$0 -> a
    void <init>(baritone.process.ExploreProcess) -> <init>
    baritone.process.ExploreProcess$Status isAlreadyExplored(int,int) -> a
    int countRemain() -> a
    void lambda$isAlreadyExplored$0(int,int) -> a
baritone.process.ExploreProcess$EitherChunk -> baritone.jl$b:
    baritone.process.ExploreProcess$IChunkFilter a -> a
    baritone.process.ExploreProcess$IChunkFilter b -> b
    void <init>(baritone.process.ExploreProcess$IChunkFilter,baritone.process.ExploreProcess$IChunkFilter) -> <init>
    baritone.process.ExploreProcess$Status isAlreadyExplored(int,int) -> a
    int countRemain() -> a
baritone.process.ExploreProcess$IChunkFilter -> baritone.jl$c:
    baritone.process.ExploreProcess$Status isAlreadyExplored(int,int) -> a
    int countRemain() -> a
baritone.process.ExploreProcess$JsonChunkFilter -> baritone.jl$d:
    boolean invert -> a
    it.unimi.dsi.fastutil.longs.LongOpenHashSet inFilter -> a
    baritone.api.utils.MyChunkPos[] positions -> a
    baritone.process.ExploreProcess this$0 -> a
    void <init>(baritone.process.ExploreProcess,java.nio.file.Path,boolean) -> <init>
    baritone.process.ExploreProcess$Status isAlreadyExplored(int,int) -> a
    int countRemain() -> a
baritone.process.ExploreProcess$Status -> baritone.jl$e:
    baritone.process.ExploreProcess$Status EXPLORED -> a
    baritone.process.ExploreProcess$Status NOT_EXPLORED -> b
    baritone.process.ExploreProcess$Status UNKNOWN -> c
    baritone.process.ExploreProcess$Status[] $VALUES -> a
    baritone.process.ExploreProcess$Status[] values() -> values
    baritone.process.ExploreProcess$Status valueOf(java.lang.String) -> valueOf
    void <init>(java.lang.String,int) -> <init>
    void <clinit>() -> <clinit>
baritone.process.FarmProcess -> baritone.jo:
    boolean active -> a
    java.util.List locations -> a
    int tickCount -> a
    int range -> b
    gt center -> a
    java.util.List FARMLAND_PLANTABLE -> b
    java.util.List PICKUP_DROPPED -> c
    void <init>(baritone.Baritone) -> <init>
    boolean isActive() -> a
    void farm(int,gt) -> a
    boolean readyForHarvest(cmi,gt,dbq) -> a
    boolean isPlantable(cfv) -> a
    boolean isBoneMeal(cfv) -> b
    boolean isNetherWart(cfv) -> c
    boolean isCocoa(cfv) -> d
    baritone.api.process.PathingCommand onTick(boolean,boolean) -> a
    void onLostControl() -> a
    java.lang.String displayName0() -> b
    void lambda$onTick$0(java.util.ArrayList) -> a
    void <clinit>() -> <clinit>
baritone.process.FarmProcess$Harvest -> baritone.jo$a:
    baritone.process.FarmProcess$Harvest WHEAT -> a
    baritone.process.FarmProcess$Harvest CARROTS -> b
    baritone.process.FarmProcess$Harvest POTATOES -> c
    baritone.process.FarmProcess$Harvest BEETROOT -> d
    baritone.process.FarmProcess$Harvest PUMPKIN -> e
    baritone.process.FarmProcess$Harvest MELON -> f
    baritone.process.FarmProcess$Harvest NETHERWART -> g
    baritone.process.FarmProcess$Harvest COCOA -> h
    baritone.process.FarmProcess$Harvest SUGARCANE -> i
    baritone.process.FarmProcess$Harvest BAMBOO -> j
    baritone.process.FarmProcess$Harvest CACTUS -> k
    cpi block -> a
    java.util.function.Predicate readyToHarvest -> a
    baritone.process.FarmProcess$Harvest[] $VALUES -> a
    baritone.process.FarmProcess$Harvest[] values() -> values
    baritone.process.FarmProcess$Harvest valueOf(java.lang.String) -> valueOf
    void <init>(java.lang.String,int,cqx) -> <init>
    void <init>(java.lang.String,int,cpi,java.util.function.Predicate) -> <init>
    boolean readyToHarvest(cmi,gt,dbq) -> a
    boolean lambda$static$3(dbq) -> a
    boolean lambda$static$2(dbq) -> b
    boolean lambda$static$1(dbq) -> c
    boolean lambda$static$0(dbq) -> d
    void <clinit>() -> <clinit>
baritone.process.FarmProcess$Harvest$1 -> baritone.jp:
    void <init>(java.lang.String,cpi,java.util.function.Predicate) -> <init>
    boolean readyToHarvest(cmi,gt,dbq) -> a
baritone.process.FarmProcess$Harvest$2 -> baritone.jq:
    void <init>(java.lang.String,cpi,java.util.function.Predicate) -> <init>
    boolean readyToHarvest(cmi,gt,dbq) -> a
baritone.process.FarmProcess$Harvest$3 -> baritone.jr:
    void <init>(java.lang.String,cpi,java.util.function.Predicate) -> <init>
    boolean readyToHarvest(cmi,gt,dbq) -> a
baritone.process.FollowProcess -> baritone.js:
    java.util.function.Predicate filter -> a
    java.util.List cache -> a
    boolean into -> a
    void <init>(baritone.Baritone) -> <init>
    baritone.api.process.PathingCommand onTick(boolean,boolean) -> a
    baritone.api.pathing.goals.Goal towards(bfh) -> a
    boolean followable(bfh) -> a
    void scanWorld() -> b
    boolean isActive() -> a
    void onLostControl() -> a
    java.lang.String displayName0() -> b
    void follow(java.util.function.Predicate) -> a
    void pickup(java.util.function.Predicate) -> b
    boolean lambda$pickup$1(java.util.function.Predicate,bfh) -> a
    baritone.api.pathing.goals.Goal[] lambda$onTick$0(int) -> a
baritone.process.GetToBlockProcess -> baritone.jt:
    baritone.api.utils.BlockOptionalMeta gettingTo -> a
    java.util.List knownLocations -> a
    java.util.List blacklist -> b
    gt start -> a
    int tickCount -> a
    int arrivalTickCount -> b
    void <init>(baritone.Baritone) -> <init>
    void getToBlock(baritone.api.utils.BlockOptionalMeta) -> a
    boolean isActive() -> a
    baritone.api.process.PathingCommand onTick(boolean,boolean) -> a
    boolean blacklistClosest() -> c
    void onLostControl() -> a
    java.lang.String displayName0() -> b
    void rescan(java.util.List,baritone.pathing.movement.CalculationContext) -> a
    baritone.api.pathing.goals.Goal createGoal(gt) -> a
    boolean rightClick() -> d
    boolean rightClickOnArrival(cpi) -> a
    void lambda$onTick$1(java.util.List,baritone.pathing.movement.CalculationContext) -> b
    baritone.api.pathing.goals.Goal[] lambda$onTick$0(int) -> a
    baritone.Baritone access$001(baritone.process.GetToBlockProcess) -> a
baritone.process.GetToBlockProcess$1 -> baritone.ju:
    void <init>(gt[]) -> <init>
    boolean isInGoal(int,int,int) -> a
    double heuristic() -> a
baritone.process.GetToBlockProcess$GetToBlockCalculationContext -> baritone.jt$a:
    void <init>(baritone.process.GetToBlockProcess,boolean) -> <init>
    double breakCostMultiplierAt(int,int,int,dbq) -> b
baritone.process.InventoryPauserProcess -> baritone.jv:
    boolean pauseRequestedLastTick -> a
    boolean safeToCancelLastTick -> b
    int ticksOfStationary -> a
    void <init>(baritone.Baritone) -> <init>
    boolean isActive() -> a
    boolean stationaryForInventoryMove() -> c
    baritone.api.process.PathingCommand onTick(boolean,boolean) -> a
    void onLostControl() -> a
    java.lang.String displayName0() -> b
    double priority() -> a
    boolean isTemporary() -> b
baritone.process.MineProcess -> baritone.jw:
    baritone.api.utils.BlockOptionalMetaLookup filter -> a
    java.util.List knownOreLocations -> a
    java.util.List blacklist -> b
    java.util.Map anticipatedDrops -> a
    gt branchPoint -> a
    baritone.api.pathing.goals.GoalRunAway branchPointRunaway -> a
    int desiredQuantity -> a
    int tickCount -> b
    void <init>(baritone.Baritone) -> <init>
    boolean isActive() -> a
    baritone.api.process.PathingCommand onTick(boolean,boolean) -> a
    void onLostControl() -> a
    java.lang.String displayName0() -> b
    void rescan(java.util.List,baritone.pathing.movement.CalculationContext) -> a
    boolean internalMiningGoal(gt,baritone.pathing.movement.CalculationContext,java.util.List) -> a
    java.util.List droppedItemsScan() -> a
    java.util.List searchWorld(baritone.pathing.movement.CalculationContext,baritone.api.utils.BlockOptionalMetaLookup,int,java.util.List,java.util.List,java.util.List) -> a
    boolean addNearby() -> c
    java.util.List prune(baritone.pathing.movement.CalculationContext,java.util.List,baritone.api.utils.BlockOptionalMetaLookup,int,java.util.List,java.util.List) -> a
    boolean plausibleToBreak(baritone.pathing.movement.CalculationContext,gt) -> a
    void mine(int,baritone.api.utils.BlockOptionalMetaLookup) -> a
    baritone.api.utils.BlockOptionalMetaLookup filterFilter() -> a
    baritone.api.utils.BlockOptionalMeta[] lambda$filterFilter$17(int) -> a
    boolean lambda$filterFilter$16(baritone.api.utils.BlockOptionalMeta) -> a
    boolean lambda$prune$15(java.util.List,gt) -> a
    boolean lambda$prune$14(gt) -> a
    boolean lambda$prune$13(baritone.pathing.movement.CalculationContext,gt) -> b
    boolean lambda$prune$12(baritone.pathing.movement.CalculationContext,gt) -> c
    boolean lambda$prune$11(baritone.pathing.movement.CalculationContext,gt) -> d
    boolean lambda$prune$10(baritone.pathing.movement.CalculationContext,baritone.api.utils.BlockOptionalMetaLookup,java.util.List,gt) -> a
    boolean lambda$prune$9(java.util.List,baritone.api.utils.BlockOptionalMetaLookup,baritone.pathing.movement.CalculationContext,gt) -> a
    boolean lambda$addNearby$8(gt,gt) -> a
    baritone.api.pathing.goals.Goal[] lambda$updateGoal$7(int) -> a
    baritone.api.pathing.goals.Goal lambda$updateGoal$6(java.util.List,baritone.pathing.movement.CalculationContext,gt) -> a
    void lambda$updateLoucaSystem$5(java.util.Map,gt) -> a
    boolean lambda$onTick$4(gt) -> b
    boolean lambda$onTick$3(gt) -> c
    boolean lambda$onTick$2(gt) -> d
    void lambda$onTick$1(java.util.List,baritone.pathing.movement.CalculationContext) -> b
    boolean lambda$onTick$0(cfv) -> a
baritone.process.MineProcess$1 -> baritone.jx:
    void <init>(java.lang.Integer,gt[]) -> <init>
    boolean isInGoal(int,int,int) -> a
    double heuristic() -> a
baritone.process.MineProcess$GoalThreeBlocks -> baritone.jw$a:
    void <init>(gt) -> <init>
    boolean isInGoal(int,int,int) -> a
    double heuristic(int,int,int) -> a
    boolean equals(java.lang.Object) -> equals
    int hashCode() -> hashCode
    java.lang.String toString() -> toString
baritone.process.elytra.BlockStateOctreeInterface -> baritone.jy:
    long contextPtr -> a
    long chunkPtr -> b
    int prevChunkX -> a
    int prevChunkZ -> b
    void <init>(baritone.process.elytra.NetherPathfinderContext) -> <init>
baritone.process.elytra.ElytraBehavior -> baritone.jz:
    baritone.Baritone baritone -> a
    baritone.api.utils.IPlayerContext ctx -> a
    java.util.List clearLines -> a
    java.util.List blockedLines -> b
    java.util.List simulationLine -> c
    gt aimPos -> a
    java.util.List visiblePath -> d
    baritone.process.elytra.NetherPathfinderContext context -> a
    baritone.process.elytra.ElytraBehavior$PathManager pathManager -> a
    baritone.process.ElytraProcess process -> a
    int remainingFireworkTicks -> a
    int remainingSetBackTicks -> b
    boolean landingMode -> a
    int minimumBoostTicks -> c
    boolean deployedFireworkLastTick -> b
    int[] nextTickBoostCounter -> a
    baritone.utils.BlockStateInterface bsi -> a
    baritone.process.elytra.BlockStateOctreeInterface boi -> a
    baritone.api.utils.BetterBlockPos destination -> a
    boolean appendDestination -> c
    java.util.concurrent.ExecutorService solverExecutor -> a
    java.util.concurrent.Future solver -> a
    baritone.process.elytra.ElytraBehavior$Solution pendingSolution -> a
    boolean solveNextTick -> d
    long timeLastCacheCull -> a
    int invTickCountdown -> d
    java.util.Queue invTransactionQueue -> a
    void <init>(baritone.Baritone,baritone.process.ElytraProcess,gt,boolean) -> <init>
    void onReceivePacket$1f25927f(baritone.api.utils.RayTraceUtils) -> a
    void pathTo() -> a
    void destroy() -> b
    void repackChunks() -> c
    void onPostTick(baritone.api.event.events.TickEvent) -> a
    baritone.process.elytra.ElytraBehavior$Solution solveAngles(baritone.process.elytra.ElytraBehavior$SolverContext) -> a
    void tickUseFireworks(ede,ede,boolean,boolean) -> a
    boolean isFireworks(cfv) -> a
    boolean isBoostingFireworks(cfv) -> b
    java.util.OptionalInt getFireworkBoost(cfv) -> a
    java.util.Optional getAttachedFirework() -> a
    boolean isHitboxClear(baritone.process.elytra.ElytraBehavior$SolverContext,ede,java.lang.Double) -> a
    boolean clearView(ede,ede,boolean) -> a
    it.unimi.dsi.fastutil.floats.FloatArrayList pitchesToSolveFor(float,boolean) -> a
    java.util.List simulate(baritone.process.elytra.ElytraBehavior$SolverContext,ede,float,int,int,int) -> a
    boolean passable(int,int,int,boolean) -> a
    void queueWindowClick$36476e45(int,int,cbm) -> a
    int findGoodElytra() -> a
    void logVerbose(java.lang.String) -> c
    void lambda$queueWindowClick$8(int,int,int,cbm) -> a
    baritone.process.elytra.ElytraBehavior$PitchResult lambda$solvePitch$7(baritone.process.elytra.ElytraBehavior$IntTriFunction,baritone.process.elytra.ElytraBehavior$IntTriple) -> a
    baritone.process.elytra.ElytraBehavior$PitchResult lambda$solvePitch$6(baritone.process.elytra.ElytraBehavior$IntTriFunction,baritone.process.elytra.ElytraBehavior$IntTriple) -> b
    baritone.process.elytra.ElytraBehavior$PitchResult lambda$solvePitch$5(baritone.process.elytra.ElytraBehavior$SolverContext,ede,int,it.unimi.dsi.fastutil.floats.FloatArrayList,int,int,int) -> a
    byz lambda$getAttachedFirework$4(bfh) -> a
    boolean lambda$getAttachedFirework$3(bfh) -> a
    boolean lambda$getAttachedFirework$2(bfh) -> b
    baritone.process.elytra.ElytraBehavior$Solution lambda$onPostTick$1(baritone.process.elytra.ElytraBehavior$SolverContext) -> b
    void lambda$onReceivePacket$0() -> d
baritone.process.elytra.ElytraBehavior$FireworkBoost -> baritone.jz$a:
    java.lang.Integer fireworkTicksExisted -> a
    int minimumBoostTicks -> b
    int maximumBoostTicks -> a
    void <init>(java.lang.Integer,int) -> <init>
    boolean isBoosted() -> a
    int getGuaranteedBoostTicks() -> a
    boolean equals(java.lang.Object) -> equals
baritone.process.elytra.ElytraBehavior$IntTriFunction -> baritone.jz$b:
    java.lang.Object apply(int,int,int) -> apply
baritone.process.elytra.ElytraBehavior$IntTriple -> baritone.jz$c:
    int first -> a
    int second -> b
    int third -> c
    void <init>(int,int,int) -> <init>
baritone.process.elytra.ElytraBehavior$PathManager -> baritone.jz$d:
    baritone.process.elytra.NetherPath path -> a
    boolean completePath -> a
    boolean recalculating -> b
    int maxPlayerNear -> a
    int ticksNearUnchanged -> b
    int playerNear -> c
    baritone.process.elytra.ElytraBehavior this$0 -> a
    void <init>(baritone.process.elytra.ElytraBehavior) -> <init>
    java.util.concurrent.CompletableFuture pathToDestination() -> a
    java.util.concurrent.CompletableFuture pathToDestination(gt) -> a
    java.util.concurrent.CompletableFuture pathRecalcSegment(java.util.OptionalInt) -> a
    void pathNextSegment(int) -> a
    void clear() -> a
    void setPath(baritone.process.elytra.UnpackedSegment) -> a
    java.util.concurrent.CompletableFuture path0(gt,gt,java.util.function.UnaryOperator) -> a
    void pathfindAroundObstacles() -> b
    void updatePlayerNear() -> c
    void lambda$pathfindAroundObstacles$9() -> d
    void lambda$pathfindAroundObstacles$8(baritone.api.utils.BetterBlockPos,double,long) -> a
    void lambda$pathfindAroundObstacles$7() -> e
    void lambda$pathNextSegment$6(baritone.api.utils.BetterBlockPos,java.lang.Void,java.lang.Throwable) -> a
    void lambda$pathNextSegment$5(java.util.List,long) -> a
    baritone.process.elytra.UnpackedSegment lambda$pathNextSegment$4(java.util.List,baritone.process.elytra.UnpackedSegment) -> a
    void lambda$pathRecalcSegment$3(java.lang.Void,java.lang.Throwable) -> a
    baritone.process.elytra.UnpackedSegment lambda$pathRecalcSegment$2(java.util.List,boolean,java.util.OptionalInt,baritone.process.elytra.UnpackedSegment) -> a
    void lambda$pathToDestination$1(java.lang.Void,java.lang.Throwable) -> b
    void lambda$pathToDestination$0(long) -> a
baritone.process.elytra.ElytraBehavior$PitchResult -> baritone.jz$e:
    float pitch -> a
    double dot -> a
    java.util.List steps -> a
    void <init>(float,double,java.util.List) -> <init>
baritone.process.elytra.ElytraBehavior$Solution -> baritone.jz$f:
    baritone.process.elytra.ElytraBehavior$SolverContext context -> a
    baritone.api.utils.Rotation rotation -> a
    ede goingTo -> a
    boolean solvedPitch -> a
    boolean forceUseFirework -> b
    void <init>(baritone.process.elytra.ElytraBehavior$SolverContext,baritone.api.utils.Rotation,ede,boolean,boolean) -> <init>
baritone.process.elytra.ElytraBehavior$SolverContext -> baritone.jz$g:
    baritone.process.elytra.NetherPath path -> a
    int playerNear -> a
    ede start -> a
    ede motion -> b
    ecz boundingBox -> a
    boolean ignoreLava -> a
    baritone.process.elytra.ElytraBehavior$FireworkBoost boost -> a
    baritone.api.behavior.look.IAimProcessor aimProcessor -> a
    void <init>(baritone.process.elytra.ElytraBehavior,boolean) -> <init>
    boolean equals(java.lang.Object) -> equals
    java.lang.Integer lambda$new$0(byz) -> a
baritone.process.elytra.NetherPath -> baritone.ka:
    baritone.process.elytra.NetherPath EMPTY_PATH -> a
    java.util.List backing -> a
    void <init>(java.util.List) -> <init>
    baritone.api.utils.BetterBlockPos get(int) -> a
    int size() -> size
    baritone.api.utils.BetterBlockPos getLast() -> a
    ede getVec(int) -> a
    baritone.process.elytra.NetherPath emptyPath() -> a
    java.lang.Object get(int) -> get
    void <clinit>() -> <clinit>
baritone.process.elytra.NetherPathfinderContext -> baritone.kb:
    dbq AIR_BLOCK_STATE -> a
    java.lang.Object cullingLock -> a
    long context -> a
    long seed -> b
    java.util.concurrent.ExecutorService executor -> a
    void <init>(long) -> <init>
    void queueCacheCulling(int,int,int,baritone.process.elytra.BlockStateOctreeInterface) -> a
    void queueForPacking(ddy) -> a
    void queueBlockUpdate$4a8de162(baritone.api.utils.NotificationHelper) -> a
    java.util.concurrent.CompletableFuture pathFindAsync(gt,gt) -> a
    boolean raytrace(ede,ede) -> a
    boolean isSupported() -> a
    dev.babbaj.pathfinder.PathSegment lambda$pathFindAsync$4(gt,gt) -> a
    void lambda$queueBlockUpdate$3$4a8de162(baritone.api.utils.NotificationHelper) -> b
    void lambda$queueBlockUpdate$2(long,baritone.api.utils.Pair) -> a
    void lambda$queueForPacking$1(java.lang.ref.SoftReference) -> a
    void lambda$queueCacheCulling$0(baritone.process.elytra.BlockStateOctreeInterface,int,int,int) -> a
    void <clinit>() -> <clinit>
baritone.process.elytra.NullElytraProcess -> baritone.kc:
    void <init>(baritone.Baritone) -> <init>
    void repackChunks() -> b
    void pathTo(baritone.api.pathing.goals.Goal) -> a
    void resetState() -> c
    boolean isActive() -> a
    baritone.api.process.PathingCommand onTick(boolean,boolean) -> a
    void onLostControl() -> a
    java.lang.String displayName0() -> b
    boolean isLoaded() -> c
    boolean isSafeToCancel() -> d
baritone.process.elytra.PathCalculationException -> baritone.kd:
    void <init>(java.lang.String) -> <init>
baritone.process.elytra.UnpackedSegment -> baritone.ke:
    java.util.stream.Stream path -> a
    boolean finished -> a
    void <init>(java.util.stream.Stream,boolean) -> <init>
    baritone.process.elytra.UnpackedSegment from(dev.babbaj.pathfinder.PathSegment) -> a
baritone.selection.Selection -> baritone.kf:
    baritone.api.utils.BetterBlockPos pos1 -> a
    baritone.api.utils.BetterBlockPos pos2 -> b
    baritone.api.utils.BetterBlockPos min -> c
    baritone.api.utils.BetterBlockPos max -> d
    hy size -> a
    ecz aabb -> a
    void <init>(baritone.api.utils.BetterBlockPos,baritone.api.utils.BetterBlockPos) -> <init>
    baritone.api.utils.BetterBlockPos pos1() -> a
    baritone.api.utils.BetterBlockPos pos2() -> b
    baritone.api.utils.BetterBlockPos min() -> c
    baritone.api.utils.BetterBlockPos max() -> d
    hy size() -> a
    ecz aabb() -> a
    int hashCode() -> hashCode
    java.lang.String toString() -> toString
    boolean isPos2(gz) -> a
    baritone.api.selection.ISelection expand(gz,int) -> a
    baritone.api.selection.ISelection contract(gz,int) -> b
    baritone.api.selection.ISelection shift(gz,int) -> c
baritone.selection.Selection$1 -> baritone.kg:
    int[] $SwitchMap$net$minecraft$core$Direction$Axis -> a
    void <clinit>() -> <clinit>
baritone.selection.SelectionManager -> baritone.kh:
    java.util.LinkedList selections -> a
    baritone.api.selection.ISelection[] selectionsArr -> a
    void <init>(baritone.Baritone) -> <init>
    void resetSelectionsArr() -> a
    baritone.api.selection.ISelection addSelection(baritone.api.selection.ISelection) -> b
    baritone.api.selection.ISelection addSelection(baritone.api.utils.BetterBlockPos,baritone.api.utils.BetterBlockPos) -> a
    baritone.api.selection.ISelection removeSelection(baritone.api.selection.ISelection) -> a
    baritone.api.selection.ISelection[] removeAllSelections() -> a
    baritone.api.selection.ISelection[] getSelections() -> b
    baritone.api.selection.ISelection expand(baritone.api.selection.ISelection,gz,int) -> a
    baritone.api.selection.ISelection contract(baritone.api.selection.ISelection,gz,int) -> b
    baritone.api.selection.ISelection shift(baritone.api.selection.ISelection,gz,int) -> c
baritone.selection.SelectionRenderer -> baritone.ki:
    baritone.selection.SelectionManager manager -> a
    void <init>(baritone.Baritone,baritone.selection.SelectionManager) -> <init>
    void onRenderPass$493a6673(baritone.cache.ChunkPacker) -> a
baritone.utils.BaritoneProcessHelper -> baritone.kj:
    baritone.Baritone baritone -> a
    baritone.api.utils.IPlayerContext ctx -> a
    void <init>(baritone.Baritone) -> <init>
    boolean isTemporary() -> b
baritone.utils.BlockBreakHelper -> baritone.kk:
    baritone.api.utils.IPlayerContext ctx -> a
    boolean wasHitting -> a
    int breakDelayTimer -> a
    void <init>(baritone.api.utils.IPlayerContext) -> <init>
    void stopBreakingBlock() -> a
baritone.utils.BlockPlaceHelper -> baritone.kl:
    baritone.api.utils.IPlayerContext ctx -> a
    int rightClickTimer -> a
    void <init>(baritone.api.utils.IPlayerContext) -> <init>
baritone.utils.BlockStateInterface -> baritone.km:
    fdh provider -> a
    baritone.cache.WorldData worldData -> a
    cmi world -> a
    gt$a isPassableBlockPos -> a
    clo access -> a
    baritone.utils.pathing.BetterWorldBorder worldBorder -> a
    ddy prev -> a
    baritone.cache.CachedRegion prevCached -> a
    boolean useTheRealWorld -> a
    dbq AIR -> a
    void <init>(baritone.api.utils.IPlayerContext) -> <init>
    void <init>(baritone.api.utils.IPlayerContext,boolean) -> <init>
    boolean worldContainsLoadedChunk(int,int) -> a
    cpi getBlock(baritone.api.utils.IPlayerContext,gt) -> a
    dbq get(baritone.api.utils.IPlayerContext,gt) -> a
    dbq get0(gt) -> a
    dbq get0(int,int,int) -> a
    dbq getFromChunk(ddy,int,int,int) -> a
    void <clinit>() -> <clinit>
baritone.utils.BlockStateInterfaceAccessWrapper -> baritone.kn:
    baritone.utils.BlockStateInterface bsi -> a
    void <init>(baritone.utils.BlockStateInterface) -> <init>
    cze c_(gt) -> c_
    dbq a_(gt) -> a_
    dwj b_(gt) -> b_
    int w_() -> w_
    int v_() -> v_
baritone.utils.GuiClick -> baritone.ko:
    org.joml.Matrix4f projectionViewMatrix -> a
    gt clickStart -> a
    gt currentMouseOver -> b
    void <init>() -> <init>
    boolean aB_() -> aB_
    void a(ehe,int,int,float) -> a
    boolean b(double,double,int) -> b
    boolean a(double,double,int) -> a
    ede toWorld(double,double,double) -> a
baritone.utils.IRenderer -> baritone.kp:
    ehg tessellator -> a
    egz buffer -> a
    baritone.utils.accessor.IEntityRenderManager renderManager -> a
    ftd textureManager -> a
    baritone.api.Settings settings -> a
    float[] color -> a
    void glColor(java.awt.Color,float) -> a
    void startLines(java.awt.Color,float,float,boolean) -> a
    void startLines(java.awt.Color,float,boolean) -> a
    void endLines(boolean) -> a
    void emitLine(ehe,double,double,double,double,double,double) -> a
    void emitLine(ehe,double,double,double,double,double,double,double,double,double) -> a
    void emitLine(ehe,float,float,float,float,float,float,float,float,float) -> a
    void emitAABB(ehe,ecz) -> a
    void emitAABB(ehe,ecz,double) -> a
    void emitLine(ehe,ede,ede) -> a
    void <clinit>() -> <clinit>
baritone.utils.InputOverrideHandler -> baritone.kq:
    java.util.Map inputForceStateMap -> a
    baritone.utils.BlockBreakHelper blockBreakHelper -> a
    baritone.utils.BlockPlaceHelper blockPlaceHelper -> a
    void <init>(baritone.Baritone) -> <init>
    boolean isInputForcedDown(baritone.api.utils.input.Input) -> a
    void setInputForceState(baritone.api.utils.input.Input,boolean) -> a
    void clearAllKeys() -> a
    void onTick(baritone.api.event.events.TickEvent) -> a
baritone.utils.PathRenderer -> baritone.kr:
    add TEXTURE_BEACON_BEAM -> a
    double posX() -> a
    double posY() -> b
    double posZ() -> c
    void render$3f238dfb(baritone.cache.ChunkPacker,baritone.behavior.PathingBehavior) -> a
    void drawPath$6964883e(ehe,java.util.List,int,java.awt.Color,boolean) -> a
    void drawPath(ehe,java.util.List,int,java.awt.Color,boolean,int,int,double) -> a
    void emitPathLine(ehe,double,double,double,double,double,double,double) -> a
    void drawManySelectionBoxes(ehe,bfh,java.util.Collection,java.awt.Color) -> a
    void drawGoal(ehe,baritone.api.utils.IPlayerContext,baritone.api.pathing.goals.Goal,float,java.awt.Color) -> a
    void drawGoal(ehe,baritone.api.utils.IPlayerContext,baritone.api.pathing.goals.Goal,float,java.awt.Color,boolean) -> a
    void drawDankLitGoalBox(ehe,java.awt.Color,double,double,double,double,double,double,double,double,boolean) -> a
    void renderHorizontalQuad(ehe,double,double,double,double,double) -> a
    void lambda$drawManySelectionBoxes$3(baritone.utils.BlockStateInterface,bfh,ehe,gt) -> a
    void lambda$render$2$1b087156(baritone.cache.ChunkPacker,baritone.api.utils.IPlayerContext,baritone.pathing.calc.AbstractNodeCostSearch) -> a
    void lambda$render$1$14b79f0a(baritone.cache.ChunkPacker,baritone.api.utils.IPlayerContext,baritone.api.pathing.calc.IPath) -> a
    void lambda$render$0$67adce(baritone.cache.ChunkPacker,baritone.api.pathing.calc.IPath) -> a
    void <clinit>() -> <clinit>
baritone.utils.PathingCommandContext -> baritone.ks:
    baritone.pathing.movement.CalculationContext desiredCalcContext -> a
    void <init>(baritone.api.pathing.goals.Goal,baritone.api.process.PathingCommandType,baritone.pathing.movement.CalculationContext) -> <init>
baritone.utils.PathingControlManager -> baritone.kt:
    baritone.Baritone baritone -> a
    java.util.HashSet processes -> a
    java.util.List active -> a
    baritone.api.process.IBaritoneProcess inControlLastTick -> b
    baritone.api.process.IBaritoneProcess inControlThisTick -> a
    baritone.api.process.PathingCommand command -> a
    void <init>(baritone.Baritone) -> <init>
    void registerProcess(baritone.api.process.IBaritoneProcess) -> a
    void cancelEverything() -> a
    java.util.Optional mostRecentInControl() -> a
    java.util.Optional mostRecentCommand() -> b
    void preTick() -> b
    boolean revalidateGoal(baritone.api.pathing.goals.Goal) -> a
baritone.utils.PathingControlManager$1 -> baritone.ku:
    baritone.utils.PathingControlManager this$0 -> a
    void <init>(baritone.utils.PathingControlManager) -> <init>
    void onTick(baritone.api.event.events.TickEvent) -> a
baritone.utils.PathingControlManager$2 -> baritone.kv:
    int[] $SwitchMap$baritone$api$process$PathingCommandType -> a
    void <clinit>() -> <clinit>
baritone.utils.PlayerMovementInput -> baritone.kw:
    baritone.utils.InputOverrideHandler handler -> a
    void <init>(baritone.utils.InputOverrideHandler) -> <init>
    void a(boolean,float) -> a
baritone.utils.ToolSet -> baritone.kx:
    java.util.Map breakStrengthCache -> a
    java.util.function.Function backendCalculation -> a
    fhk player -> a
    void <init>(fhk) -> <init>
    double getStrVsBlock(dbq) -> a
    int getMaterialCost(cfv) -> a
    boolean hasSilkTouch(cfv) -> a
    int getBestSlot(cpi,boolean,boolean) -> a
    double getBestDestructionTime(cpi) -> a
    double calculateSpeedVsBlock(cfv,dbq) -> a
    java.lang.Double lambda$new$0(double,java.lang.Double) -> a
baritone.utils.accessor.IChunkArray -> baritone.ky:
    void copyFrom(baritone.utils.accessor.IChunkArray) -> copyFrom
    java.util.concurrent.atomic.AtomicReferenceArray getChunks() -> getChunks
    int centerX() -> centerX
    int centerZ() -> centerZ
    int viewDistance() -> viewDistance
baritone.utils.accessor.IClientChunkProvider -> baritone.kz:
    fdh createThreadSafeCopy() -> createThreadSafeCopy
    baritone.utils.accessor.IChunkArray extractReferenceArray() -> extractReferenceArray
baritone.utils.accessor.IEntityRenderManager -> baritone.la:
    double renderPosX() -> renderPosX
    double renderPosY() -> renderPosY
    double renderPosZ() -> renderPosZ
baritone.utils.accessor.IFireworkRocketEntity -> baritone.lb:
    bfx getBoostedEntity() -> getBoostedEntity
baritone.utils.accessor.IGuiScreen -> baritone.lc:
    void openLinkInvoker(java.net.URI) -> openLinkInvoker
baritone.utils.accessor.IPalettedContainer -> baritone.ld:
    ded getPalette() -> getPalette
    aoc getStorage() -> getStorage
baritone.utils.accessor.IPalettedContainer$IData -> baritone.ld$a:
    ded getPalette() -> getPalette
    aoc getStorage() -> getStorage
baritone.utils.accessor.IPlayerControllerMP -> baritone.le:
    void setIsHittingBlock(boolean) -> setIsHittingBlock
    boolean isHittingBlock() -> isHittingBlock
    void callSyncCurrentPlayItem() -> callSyncCurrentPlayItem
    void setDestroyDelay(int) -> setDestroyDelay
baritone.utils.pathing.Avoidance -> baritone.lf:
    int centerX -> a
    int centerY -> b
    int centerZ -> c
    double coefficient -> a
    int radius -> d
    void <init>(gt,double,int) -> <init>
    void <init>(int,int,int,double,int) -> <init>
    java.util.List create(baritone.api.utils.IPlayerContext) -> a
    void lambda$create$5(java.util.List,double,bfh) -> a
    boolean lambda$create$4(bfh) -> a
    boolean lambda$create$3(bfh) -> b
    boolean lambda$create$2(baritone.api.utils.IPlayerContext,bfh) -> a
    boolean lambda$create$1(bfh) -> c
    void lambda$create$0(java.util.List,double,gt) -> a
baritone.utils.pathing.BetterWorldBorder -> baritone.lg:
    double minX -> a
    double maxX -> b
    double minZ -> c
    double maxZ -> d
    void <init>(ddi) -> <init>
    boolean entirelyContains(int,int) -> a
    boolean canPlaceAt(int,int) -> b
baritone.utils.pathing.Favoring -> baritone.lh:
    it.unimi.dsi.fastutil.longs.Long2DoubleOpenHashMap favorings -> a
    void <init>(baritone.api.utils.IPlayerContext,baritone.api.pathing.calc.IPath,baritone.pathing.movement.CalculationContext) -> <init>
    void <init>(baritone.api.pathing.calc.IPath,baritone.pathing.movement.CalculationContext) -> <init>
    void lambda$new$0(double,baritone.api.utils.BetterBlockPos) -> a
baritone.utils.pathing.MutableMoveResult -> baritone.li:
    int x -> a
    int y -> b
    int z -> c
    double cost -> a
    void <init>() -> <init>
    void reset() -> a
baritone.utils.pathing.PathBase -> baritone.lj:
    void <init>() -> <init>
    baritone.api.pathing.calc.IPath staticCutoff(baritone.api.pathing.goals.Goal) -> a
    baritone.api.pathing.calc.IPath cutoffAtLoadedChunks(java.lang.Object) -> a
baritone.utils.pathing.PathingBlockType -> baritone.lk:
    baritone.utils.pathing.PathingBlockType AIR -> a
    baritone.utils.pathing.PathingBlockType WATER -> b
    baritone.utils.pathing.PathingBlockType AVOID -> c
    baritone.utils.pathing.PathingBlockType SOLID -> d
    boolean[] bits -> a
    baritone.utils.pathing.PathingBlockType[] $VALUES -> a
    baritone.utils.pathing.PathingBlockType[] values() -> values
    baritone.utils.pathing.PathingBlockType valueOf(java.lang.String) -> valueOf
    void <init>(java.lang.String,int,int) -> <init>
    baritone.utils.pathing.PathingBlockType fromBits(boolean,boolean) -> a
    void <clinit>() -> <clinit>
baritone.utils.player.BaritonePlayerContext -> baritone.ll:
    baritone.Baritone baritone -> a
    emh mc -> a
    baritone.api.utils.IPlayerController playerController -> a
    void <init>(baritone.Baritone,emh) -> <init>
    emh minecraft() -> a
    fhk player() -> a
    baritone.api.utils.IPlayerController playerController() -> a
    cmi world() -> a
    baritone.api.cache.IWorldData worldData() -> a
    baritone.api.utils.BetterBlockPos viewerPos() -> b
    baritone.api.utils.Rotation playerRotations() -> a
    edc objectMouseOver() -> a
    baritone.api.utils.Rotation lambda$playerRotations$0() -> b
baritone.utils.player.BaritonePlayerController -> baritone.lm:
    emh mc -> a
    void <init>(emh) -> <init>
    void syncHeldItem() -> a
    boolean hasBrokenBlock() -> a
    boolean onPlayerDamageBlock(gt,gz) -> a
    void resetBlockRemoving() -> b
    void windowClick(int,int,int,cbm,bym) -> a
    cmf getGameType() -> a
    bdy processRightClickBlock$2cbe52ad(fhk,bdx,eda) -> a
    bdy processRightClick$59eb671a(fhk,bdx) -> a
    boolean clickBlock(gt,gz) -> b
    void setHittingBlock(boolean) -> a
baritone.utils.schematic.MapArtSchematic -> baritone.ln:
    int[][] heightMap -> a
    void <init>(baritone.api.schematic.IStaticSchematic) -> <init>
    boolean partOfMask(int,int,int,dbq) -> b
    boolean lambda$generateHeightMap$0(dbq) -> a
baritone.utils.schematic.SchematicSystem -> baritone.lo:
    baritone.utils.schematic.SchematicSystem INSTANCE -> a
    baritone.api.command.registry.Registry registry -> a
    baritone.utils.schematic.SchematicSystem[] $VALUES -> a
    baritone.utils.schematic.SchematicSystem[] values() -> values
    baritone.utils.schematic.SchematicSystem valueOf(java.lang.String) -> valueOf
    void <init>(java.lang.String) -> <init>
    java.util.Optional getByFile(java.io.File) -> a
    java.util.List getFileExtensions() -> a
    boolean lambda$getByFile$0(java.io.File,baritone.api.schematic.format.ISchematicFormat) -> a
    void <clinit>() -> <clinit>
baritone.utils.schematic.SelectionSchematic -> baritone.lp:
    baritone.api.selection.ISelection[] selections -> a
    void <init>(baritone.api.schematic.ISchematic,hy,baritone.api.selection.ISelection[]) -> <init>
    boolean partOfMask(int,int,int,dbq) -> b
    baritone.api.selection.ISelection[] lambda$new$1(int) -> a
    baritone.api.selection.ISelection lambda$new$0(hy,baritone.api.selection.ISelection) -> a
baritone.utils.schematic.StaticSchematic -> baritone.lq:
    dbq[][][] states -> a
    void <init>() -> <init>
    void <init>(dbq[][][]) -> <init>
    dbq desiredState(int,int,int,dbq,java.util.List) -> a
    dbq getDirect(int,int,int) -> a
    dbq[] getColumn(int,int) -> a
baritone.utils.schematic.format.DefaultSchematicFormats -> baritone.lr:
    baritone.utils.schematic.format.DefaultSchematicFormats MCEDIT -> a
    baritone.utils.schematic.format.DefaultSchematicFormats SPONGE -> b
    baritone.utils.schematic.format.DefaultSchematicFormats LITEMATICA -> c
    java.lang.String extension -> a
    baritone.utils.schematic.format.DefaultSchematicFormats[] $VALUES -> a
    baritone.utils.schematic.format.DefaultSchematicFormats[] values() -> values
    baritone.utils.schematic.format.DefaultSchematicFormats valueOf(java.lang.String) -> valueOf
    void <init>(java.lang.String,int,java.lang.String) -> <init>
    boolean isFileType(java.io.File) -> a
    java.util.List getFileExtensions() -> a
    void <clinit>() -> <clinit>
baritone.utils.schematic.format.DefaultSchematicFormats$1 -> baritone.ls:
    void <init>(java.lang.String,java.lang.String) -> <init>
    baritone.api.schematic.IStaticSchematic parse(java.io.InputStream) -> a
baritone.utils.schematic.format.DefaultSchematicFormats$2 -> baritone.lt:
    void <init>(java.lang.String,java.lang.String) -> <init>
    baritone.api.schematic.IStaticSchematic parse(java.io.InputStream) -> a
baritone.utils.schematic.format.DefaultSchematicFormats$3 -> baritone.lu:
    void <init>(java.lang.String,java.lang.String) -> <init>
    baritone.api.schematic.IStaticSchematic parse(java.io.InputStream) -> a
baritone.utils.schematic.format.defaults.LitematicaSchematic -> baritone.lv:
    void <init>(re) -> <init>
    re[] getRegions(re) -> a
    int getMinOfSubregion(re,java.lang.String) -> a
    dbq[] getBlockList(rk) -> a
    dbq getBlockState(cpi,re) -> a
    int getMinOfSchematic(re,java.lang.String) -> b
    void writeSubregionIntoSchematic(re,hy,dbq[],baritone.utils.schematic.format.defaults.LitematicaSchematic$LitematicaBitArray) -> a
    dbq getDirect(int,int,int) -> a
    re[] lambda$getRegions$0(int) -> a
baritone.utils.schematic.format.defaults.LitematicaSchematic$LitematicaBitArray -> baritone.lv$a:
    long[] longArray -> a
    int bitsPerEntry -> a
    long maxEntryValue -> a
    long arraySize -> b
    void <init>(int,long,long[]) -> <init>
baritone.utils.schematic.format.defaults.MCEditSchematic -> baritone.lw:
    void <init>(re) -> <init>
baritone.utils.schematic.format.defaults.SpongeSchematic -> baritone.lx:
    void <init>(re) -> <init>
baritone.utils.schematic.format.defaults.SpongeSchematic$SerializedBlockState -> baritone.lx$a:
    java.util.regex.Pattern REGEX -> a
    add resourceLocation -> a
    java.util.Map properties -> a
    dbq blockState -> a
    void <init>(add,java.util.Map) -> <init>
    dbq deserialize() -> a
    baritone.utils.schematic.format.defaults.SpongeSchematic$SerializedBlockState getFromString(java.lang.String) -> a
    void lambda$deserialize$0(cpi,java.lang.String) -> a
    void <clinit>() -> <clinit>
baritone.utils.schematic.litematica.LitematicaHelper -> baritone.utils.schematic.litematica.LitematicaHelper:
    void <init>() -> <init>
    boolean isLitematicaPresent() -> a
    boolean hasLoadedSchematic(int) -> a
    hy transform(hy,cua,cvq) -> a
    aqh getSchematic(int) -> a
baritone.utils.schematic.litematica.LitematicaHelper$1 -> baritone.utils.schematic.litematica.LitematicaHelper$1:
    int[] $SwitchMap$net$minecraft$world$level$block$Rotation -> a
    void <clinit>() -> <clinit>
baritone.utils.schematic.litematica.LitematicaHelper$LitematicaPlacementSchematic -> baritone.utils.schematic.litematica.LitematicaHelper$LitematicaPlacementSchematic:
    java.lang.String name -> a
    void <init>(java.lang.String) -> <init>
    dbq getDirect(int,int,int) -> a
    java.lang.String toString() -> toString
baritone.utils.schematic.schematica.SchematicAdapter -> baritone.utils.schematic.schematica.SchematicAdapter:
    com.github.lunatrius.schematica.client.world.SchematicWorld schematic -> a
    dbq desiredState(int,int,int,dbq,java.util.List) -> a
    dbq getDirect(int,int,int) -> a
    int widthX() -> a
    int heightY() -> b
    int lengthZ() -> c
baritone.utils.schematic.schematica.SchematicaHelper -> baritone.utils.schematic.schematica.SchematicaHelper:
    baritone.utils.schematic.schematica.SchematicaHelper[] $VALUES -> a
    baritone.utils.schematic.schematica.SchematicaHelper[] values() -> values
    baritone.utils.schematic.schematica.SchematicaHelper valueOf(java.lang.String) -> valueOf
    void <clinit>() -> <clinit>
baritone.utils.type.VarInt -> baritone.ly:
    int value -> a
    byte[] serialized -> a
    int size -> b
    void <init>(int) -> <init>
    byte[] serialize0(int) -> a
    baritone.utils.type.VarInt read(byte[],int) -> a
